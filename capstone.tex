\documentclass{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\usepackage{setspace}

\newcommand{\packageGraphicx}{\usepackage{graphicx}}
\newcommand{\packageHyperref}{\usepackage{hyperref}}
\newcommand{\renewrmdefault}{\renewcommand{\rmdefault}{ptm}}
\newcommand{\packageRelsize}{\usepackage{relsize}}
\newcommand{\packageMathabx}{\usepackage{mathabx}}
% Avoid conflicts between "mathabx" and "wasysym":
\newcommand{\packageWasysym}{
  \let\leftmoon\relax \let\rightmoon\relax \let\fullmoon\relax \let\newmoon\relax \let\diameter\relax
  \usepackage{wasysym}}
\newcommand{\packageTextcomp}{\usepackage{textcomp}}
\newcommand{\packageFramed}{\usepackage{framed}}
\newcommand{\packageHyphenat}{\usepackage[htt]{hyphenat}}
\newcommand{\packageColor}{\usepackage[usenames,dvipsnames]{color}}
\newcommand{\doHypersetup}{\hypersetup{bookmarks=true,bookmarksopen=true,bookmarksnumbered=true}}
\newcommand{\packageTocstyle}{\IfFileExists{tocstyle.sty}{\usepackage{tocstyle}\usetocstyle{standard}}{}}
\newcommand{\packageCJK}{\IfFileExists{CJK.sty}{\usepackage{CJK}}{}}
% this bit intentionally left blank
% This is the default style configuration for Scribble-generated Latex

\packageGraphicx
\packageHyperref
\renewrmdefault
\packageRelsize
\packageMathabx
\packageWasysym
\packageTextcomp
\packageFramed
\packageHyphenat
\packageColor
\doHypersetup
\packageTocstyle
\packageCJK


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Configuration that is especially meant to be overridden:

% Inserted before every ``chapter'', useful for starting each one on a new page:
\newcommand{\sectionNewpage}{}
% Inserted before every book ``part''
\newcommand{\partNewpage}{\sectionNewpage}

% Hooks for actions within the `document' environment:
\newcommand{\preDoc}{}
\newcommand{\postDoc}{}

% Generated by `secref'; first arg is section number, second is section title:
\newcommand{\BookRef}[2]{\emph{#2}}
\newcommand{\ChapRef}[2]{\SecRef{#1}{#2}}
\newcommand{\SecRef}[2]{section~#1}
\newcommand{\PartRef}[2]{part~#1}
% Generated by `Secref':
\newcommand{\BookRefUC}[2]{\BookRef{#1}{#2}}
\newcommand{\ChapRefUC}[2]{\SecRefUC{#1}{#2}}
\newcommand{\SecRefUC}[2]{Section~#1}
\newcommand{\PartRefUC}[2]{Part~#1}

% Variants of the above with a label for an internal reference:
\newcommand{\BookRefLocal}[3]{\hyperref[#1]{\BookRef{#2}{#3}}}
\newcommand{\ChapRefLocal}[3]{\hyperref[#1]{\ChapRef{#2}{#3}}}
\newcommand{\SecRefLocal}[3]{\hyperref[#1]{\SecRef{#2}{#3}}}
\newcommand{\PartRefLocal}[3]{\hyperref[#1]{\PartRef{#2}{#3}}}
\newcommand{\BookRefLocalUC}[3]{\hyperref[#1]{\BookRefUC{#2}{#3}}}
\newcommand{\ChapRefLocalUC}[3]{\hyperref[#1]{\ChapRefUC{#2}{#3}}}
\newcommand{\SecRefLocalUC}[3]{\hyperref[#1]{\SecRefUC{#2}{#3}}}
\newcommand{\PartRefLocalUC}[3]{\hyperref[#1]{\PartRefUC{#2}{#3}}}

% Variants of the above with a section number is empty (i.e., UnNumbered):
\newcommand{\BookRefUN}[1]{\BookRef{}{#1}}
\newcommand{\ChapRefUN}[1]{\SecRefUN{#1}}
\newcommand{\SecRefUN}[1]{``#1''}
\newcommand{\PartRefUN}[1]{\SecRefUN{#1}}
\newcommand{\BookRefUCUN}[1]{\BookRefUN{#1}}
\newcommand{\ChapRefUCUN}[1]{\ChapRefUN{#1}}
\newcommand{\SecRefUCUN}[1]{\SecRefUN{#1}}
\newcommand{\PartRefUCUN}[1]{\PartRefUN{#1}}

\newcommand{\BookRefLocalUN}[2]{\hyperref[#1]{\BookRefUN{#2}}}
\newcommand{\ChapRefLocalUN}[2]{\SecRefLocalUN{#1}{#2}}
\newcommand{\SecRefLocalUN}[2]{\hyperref[#1]{\SecRefUN{#2}}}
\newcommand{\PartRefLocalUN}[2]{\SecRefLocalUN{#1}{#2}}
\newcommand{\BookRefLocalUCUN}[2]{\BookRefLocalUN{#1}{#2}}
\newcommand{\ChapRefLocalUCUN}[2]{\ChapRefLocalUN{#1}{#2}}
\newcommand{\SecRefLocalUCUN}[2]{\SecRefLocalUN{#1}{#2}}
\newcommand{\PartRefLocalUCUN}[2]{\PartRefLocalUN{#1}{#2}}

\newcommand{\SectionNumberLink}[2]{\hyperref[#1]{#2}}

% Enabled with a 'enable-index-merge part style property. This default
% implementation isn't good enough, because the argument is a
% comma-separated sequence of labels:
\newcommand{\Smanypageref}[1]{\pageref{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Fonts

% Font commands used by generated text:
\newcommand{\Scribtexttt}[1]{{\texttt{#1}}}
\newcommand{\textsub}[1]{$_{\hbox{\textsmaller{#1}}}$}
\newcommand{\textsuper}[1]{$^{\hbox{\textsmaller{#1}}}$}
\newcommand{\intextcolor}[2]{\textcolor{#1}{#2}}
\newcommand{\intextrgbcolor}[2]{\textcolor[rgb]{#1}{#2}}
\newcommand{\incolorbox}[2]{{\fboxrule=0pt\fboxsep=0pt\colorbox{#1}{#2}}}
\newcommand{\inrgbcolorbox}[2]{{\fboxrule=0pt\fboxsep=0pt\colorbox[rgb]{#1}{#2}}}
\newcommand{\plainlink}[1]{#1}
\newcommand{\techoutside}[1]{#1}
\newcommand{\techinside}[1]{#1}
\newcommand{\badlink}[1]{#1}
\newcommand{\indexlink}[1]{#1}
\newcommand{\noborder}[1]{#1}
\newcommand{\Smaller}[1]{\textsmaller{#1}}
\newcommand{\Larger}[1]{\textlarger{#1}}
\newcommand{\planetName}[1]{PLane\hspace{-0.1ex}T}
\newcommand{\slant}[1]{{\textsl{#1}}}

% Used for <, >, and | in tt mode. For some fonts and installations,
% there seems to be an encoding issue, so pick T1 explicitly:
\newcommand{\Stttextmore}{{\fontencoding{T1}\selectfont>}}
\newcommand{\Stttextless}{{\fontencoding{T1}\selectfont<}}
\newcommand{\Stttextbar}{{\fontencoding{T1}\selectfont|}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tables

% The `stabular' environment seems to be the lesser of evils among
%  page-breaking table environments (and we've made a copy as ``pltstabular'
%  to make sure that it doesn't change).

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\message{pltstabular is a modification of stabular}
%% A renamed vsetion of:
%% stabular.sty
%% Copyright 1998 Sigitas Tolu\v sis
%% VTeX Ltd., Akademijos 4, Vilnius, Lithuania
%% e-mail sigitas@vtex.lt
%% http://www.vtex.lt/tex/download/macros/
%%
% This program can redistributed and/or modified under the terms
% of the LaTeX Project Public License Distributed from CTAN
% archives in directory macros/latex/base/lppl.txt; either
% version 1 of the License, or (at your option) any later version.
%
% PURPOSE:   Improve tabular environment.
%
% SHORT DESCRIPTION:
%
% Changed internal commands: \@mkpream, \@addamp, \@xhline
%
% Provides new commands in tabular (used after command \\):
% \emptyrow[#1]
% -------------
%    Adds empty row, #1 - height of the row
%
% \tabrow{#1}[#2]
% ---------------
%    Adds row of natural height: #1\\[#2]
%
% Provides new environments: pltstabular and pltstabular*
%                            --------     ---------
%            One more multi-page version of tabular
%
%
\def\empty@finalstrut#1{%
  \unskip\ifhmode\nobreak\fi\vrule\@width\z@\@height\z@\@depth\z@}
\def\no@strut{\global\setbox\@arstrutbox\hbox{%
    \vrule \@height\z@
           \@depth\z@
           \@width\z@}%
    \gdef\@endpbox{\empty@finalstrut\@arstrutbox\par\egroup\hfil}%
}%
\def\yes@strut{\global\setbox\@arstrutbox\hbox{%
    \vrule \@height\arraystretch \ht\strutbox
           \@depth\arraystretch \dp\strutbox
           \@width\z@}%
    \gdef\@endpbox{\@finalstrut\@arstrutbox\par\egroup\hfil}%
}%
\def\@mkpream#1{\@firstamptrue\@lastchclass6
  \let\@preamble\@empty\def\empty@preamble{\add@ins}%
  \let\protect\@unexpandable@protect
  \let\@sharp\relax\let\add@ins\relax
  \let\@startpbox\relax\let\@endpbox\relax
  \@expast{#1}%
  \expandafter\@tfor \expandafter
    \@nextchar \expandafter:\expandafter=\reserved@a\do
       {\@testpach\@nextchar
    \ifcase \@chclass \@classz \or \@classi \or \@classii \or \@classiii
      \or \@classiv \or\@classv \fi\@lastchclass\@chclass}%
  \ifcase \@lastchclass \@acol
      \or \or \@preamerr \@ne\or \@preamerr \tw@\or \or \@acol \fi}
\def\@addamp{%
  \if@firstamp
    \@firstampfalse
    \edef\empty@preamble{\add@ins}%
  \else
    \edef\@preamble{\@preamble &}%
    \edef\empty@preamble{\expandafter\noexpand\empty@preamble &\add@ins}%
  \fi}
\newif\iftw@hlines \tw@hlinesfalse
\def\@xhline{\ifx\reserved@a\hline
               \tw@hlinestrue
             \else\ifx\reserved@a\Hline
               \tw@hlinestrue
             \else
               \tw@hlinesfalse
             \fi\fi
      \iftw@hlines
        \aftergroup\do@after
      \fi
      \ifnum0=`{\fi}%
}
\def\do@after{\emptyrow[\the\doublerulesep]}
\def\emptyrow{\noalign\bgroup\@ifnextchar[\@emptyrow{\@emptyrow[\z@]}}
\def\@emptyrow[#1]{\no@strut\gdef\add@ins{\vrule \@height\z@ \@depth#1 \@width\z@}\egroup%
\empty@preamble\\
\noalign{\yes@strut\gdef\add@ins{\vrule \@height\z@ \@depth\z@ \@width\z@}}%
}
\def\tabrow#1{\noalign\bgroup\@ifnextchar[{\@tabrow{#1}}{\@tabrow{#1}[]}}
\def\@tabrow#1[#2]{\no@strut\egroup#1\ifx.#2.\\\else\\[#2]\fi\noalign{\yes@strut}}
%
\def\endpltstabular{\crcr\egroup\egroup \egroup}
\expandafter \let \csname endpltstabular*\endcsname = \endpltstabular
\def\pltstabular{\let\@halignto\@empty\@pltstabular}
\@namedef{pltstabular*}#1{\def\@halignto{to#1}\@pltstabular}
\def\@pltstabular{\leavevmode \bgroup \let\@acol\@tabacol
   \let\@classz\@tabclassz
   \let\@classiv\@tabclassiv \let\\\@tabularcr\@stabarray}
\def\@stabarray{\m@th\@ifnextchar[\@sarray{\@sarray[c]}}
\def\@sarray[#1]#2{%
  \bgroup
  \setbox\@arstrutbox\hbox{%
    \vrule \@height\arraystretch\ht\strutbox
           \@depth\arraystretch \dp\strutbox
           \@width\z@}%
  \@mkpream{#2}%
  \edef\@preamble{%
    \ialign \noexpand\@halignto
      \bgroup \@arstrut \@preamble \tabskip\z@skip \cr}%
  \let\@startpbox\@@startpbox \let\@endpbox\@@endpbox
  \let\tabularnewline\\%
%    \let\par\@empty
    \let\@sharp##%
    \set@typeset@protect
    \lineskip\z@skip\baselineskip\z@skip
    \@preamble}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatother

\newenvironment{bigtabular}{\begin{pltstabular}}{\end{pltstabular}}
% For the 'boxed table style:
\newcommand{\SBoxedLeft}{\textcolor[rgb]{0.6,0.6,1.0}{\vrule width 3pt\hspace{3pt}}}
% Formerly used to keep the horizontal line for a definition on the same page:
\newcommand{\SEndFirstHead}[0]{ \nopagebreak \\ }
% Corrects weirdness when a table is the first thing in
%  an itemization:
\newcommand{\bigtableinlinecorrect}[0]{~

\vspace{-\baselineskip}\vspace{\parskip}}
% Used to indent the table correctly in an itemization, since that's
%  one of the things stabular gets wrong:
\newlength{\stabLeft}
\newcommand{\bigtableleftpad}{\hspace{\stabLeft}}
\newcommand{\atItemizeStart}[0]{\addtolength{\stabLeft}{\labelsep}
                                \addtolength{\stabLeft}{\labelwidth}}


% For a single-column table in simple environments, it's better to
%  use the `list' environment instead of `stabular'.
\newenvironment{SingleColumn}{\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=0pt\rightmargin=0pt%
\itemsep=0pt\parsep=0pt}\item}{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Etc.

% ._ and .__
\newcommand{\Sendabbrev}[1]{#1\@}
\newcommand{\Sendsentence}[1]{\@#1}

% Default style for a nested flow:
\newenvironment{Subflow}{\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=0pt\rightmargin=0pt%
\itemsep=0pt}\item}{\end{list}}

% For the 'inset nested-flow style:
\newenvironment{SInsetFlow}{\begin{quote}}{\end{quote}}

% Indent a 'code-inset nested flow:
\newcommand{\SCodePreSkip}{\vskip\abovedisplayskip}
\newcommand{\SCodePostSkip}{\vskip\belowdisplayskip}
\newenvironment{SCodeFlow}{\SCodePreSkip\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=2ex\rightmargin=2ex%
\itemsep=0pt\parsep=0pt\onehalfspacing}\item}{\end{list}\SCodePostSkip}
\newcommand{\SCodeInsetBox}[1]{\setbox1=\hbox{\hbox{\hspace{2ex}#1\hspace{2ex}}}\vbox{\SCodePreSkip\vtop{\box1\SCodePostSkip}}}

% Inset a 'vertical-inset nested flow:
\newcommand{\SVInsetPreSkip}{\vskip\abovedisplayskip}
\newcommand{\SVInsetPostSkip}{\vskip\belowdisplayskip}
\newenvironment{SVInsetFlow}{\SVInsetPreSkip\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=0pt\rightmargin=0pt%
\itemsep=0pt\parsep=0pt}\item}{\end{list}\SVInsetPostSkip}
\newcommand{\SVInsetBox}[1]{\setbox1=\hbox{\hbox{#1}}\vbox{\SCodePreSkip\vtop{\box1\SCodePostSkip}}}

% The 'compact itemization style:
\newenvironment{compact}{\begin{itemize}}{\end{itemize}}
\newcommand{\compactItem}[1]{\item #1}

% The nested-flow style for `centerline':
\newenvironment{SCentered}{\begin{trivlist}\item \centering}{\end{trivlist}}

% The \refpara command corresponds to `margin-note'. The
% refcolumn and refcontent environments also wrap the note,
% because they simplify the CSS side.
\newcommand{\refpara}[1]{\normalmarginpar\marginpar{\raggedright \footnotesize #1}}
\newcommand{\refelem}[1]{\refpara{#1}}
\newenvironment{refcolumn}{}{}
\newenvironment{refcontent}{}{}

\newcommand{\refparaleft}[1]{\reversemarginpar\marginpar{\raggedright \footnotesize #1}}
\newcommand{\refelemleft}[1]{\refparaleft{#1}}
\newenvironment{refcolumnleft}{}{}

% Macros used by `title' and `author':
\newcommand{\titleAndVersionAndAuthors}[3]{\title{#1\\{\normalsize \SVersionBefore{}#2}}\author{#3}\maketitle}
\newcommand{\titleAndVersionAndEmptyAuthors}[3]{\title{#1\\{\normalsize \SVersionBefore{}#2}}#3\maketitle}
\newcommand{\titleAndEmptyVersionAndAuthors}[3]{\title{#1}\author{#3}\maketitle}
\newcommand{\titleAndEmptyVersionAndEmptyAuthors}[3]{\title{#1}\maketitle}
\newcommand{\titleAndVersionAndAuthorsAndShort}[4]{\title[#4]{#1\\{\normalsize \SVersionBefore{}#2}}\author{#3}\maketitle}
\newcommand{\titleAndVersionAndEmptyAuthorsAndShort}[4]{\title[#4]{#1\\{\normalsize \SVersionBefore{}#2}}#3\maketitle}
\newcommand{\titleAndEmptyVersionAndAuthorsAndShort}[4]{\title[#4]{#1}\author{#3}\maketitle}
\newcommand{\titleAndEmptyVersionAndEmptyAuthorsAndShort}[4]{\title[#4]{#1}\maketitle}
\newcommand{\SAuthor}[1]{#1}
\newcommand{\SAuthorSep}[1]{\qquad}
\newcommand{\SVersionBefore}[1]{Version }

% Useful for some styles, such as sigalternate:
\newcommand{\SNumberOfAuthors}[1]{}

\let\SOriginalthesubsection\thesubsection
\let\SOriginalthesubsubsection\thesubsubsection

% sections
\newcommand{\Spart}[2]{\part[#1]{#2}}
\newcommand{\Ssection}[2]{\section[#1]{#2}\let\thesubsection\SOriginalthesubsection}
\newcommand{\Ssubsection}[2]{\subsection[#1]{#2}\let\thesubsubsection\SOriginalthesubsubsection}
\newcommand{\Ssubsubsection}[2]{\subsubsection[#1]{#2}}
\newcommand{\Ssubsubsubsection}[2]{{\bf #2}}
\newcommand{\Ssubsubsubsubsection}[2]{\Ssubsubsubsection{#1}{#2}}

% "star" means unnumbered and not in ToC:
\newcommand{\Spartstar}[1]{\part*{#1}}
\newcommand{\Ssectionstar}[1]{\section*{#1}\renewcommand*\thesubsection{\arabic{subsection}}\setcounter{subsection}{0}}
\newcommand{\Ssubsectionstar}[1]{\subsection*{#1}\renewcommand*\thesubsubsection{\arabic{section}.\arabic{subsubsection}}\setcounter{subsubsection}{0}}
\newcommand{\Ssubsubsectionstar}[1]{\subsubsection*{#1}}
\newcommand{\Ssubsubsubsectionstar}[1]{{\bf #1}}
\newcommand{\Ssubsubsubsubsectionstar}[1]{\Ssubsubsubsectionstar{#1}}

% "starx" means unnumbered but in ToC:
\newcommand{\Spartstarx}[2]{\Spartstar{#2}\addcontentsline{toc}{part}{#1}}
\newcommand{\Ssectionstarx}[2]{\Ssectionstar{#2}\addcontentsline{toc}{section}{#1}}
\newcommand{\Ssubsectionstarx}[2]{\Ssubsectionstar{#2}\addcontentsline{toc}{subsection}{#1}}
\newcommand{\Ssubsubsectionstarx}[2]{\Ssubsubsectionstar{#2}\addcontentsline{toc}{subsubsection}{#1}}
\newcommand{\Ssubsubsubsectionstarx}[2]{\Ssubsubsubsectionstar{#2}}
\newcommand{\Ssubsubsubsubsectionstarx}[2]{\Ssubsubsubsubsectionstar{#2}}

% "grouper" is for the 'grouper style variant --- on subsections and lower,
%  because \Spart is used for grouper at the section level. Grouper implies
%  unnumbered.
\newcounter{GrouperTemp}
\newcommand{\Ssubsectiongrouper}[2]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsectionstarx{#1}{#2}\setcounter{subsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsectiongrouper}[2]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstarx{#1}{#2}\setcounter{subsubsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsubsectiongrouper}[2]{\Ssubsubsubsectionstarx{#1}{#2}}
\newcommand{\Ssubsubsubsubsectiongrouper}[2]{\Ssubsubsubsubsectionstarx{#1}{#2}}

\newcommand{\Ssubsectiongrouperstar}[1]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsectionstar{#1}\setcounter{subsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsectiongrouperstar}[1]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstar{#1}\setcounter{subsubsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsubsectiongrouperstar}[1]{\Ssubsubsubsectionstar{#1}}
\newcommand{\Ssubsubsubsubsectiongrouperstar}[1]{\Ssubsubsubsubsectionstar{#1}}

\newcommand{\Ssubsectiongrouperstarx}[2]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsectionstarx{#1}{#2}\setcounter{subsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsectiongrouperstarx}[2]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstarx{#1}{#2}\setcounter{subsubsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsubsectiongrouperstarx}[2]{\Ssubsubsubsectionstarx{#1}{#2}}
\newcommand{\Ssubsubsubsubsectiongrouperstarx}[2]{\Ssubsubsubsubsectionstarx{#1}{#2}}

% Generated by `subsubsub*section':
\newcommand{\SSubSubSubSection}[1]{\Ssubsubsubsubsectionstar{#1}}

% For hidden parts with an empty title:
\newcommand{\notitlesection}{\vspace{2ex}\phantomsection\noindent}

% To increments section numbers:
\newcommand{\Sincpart}{\stepcounter{part}}
\newcommand{\Sincsection}{\stepcounter{section}}
\newcommand{\Sincsubsection}{\stepcounter{subsection}}
\newcommand{\Sincsubsubsection}{\stepcounter{subsubsection}}
\newcommand{\Sincsubsubsubsection}{}
\newcommand{\Sincsubsubsubsubsection}{}

% When brackets appear in section titles:
\newcommand{\SOpenSq}{[}
\newcommand{\SCloseSq}{]}

% Helper for box-mode macros:
\newcommand{\Svcenter}[1]{$\vcenter{#1}$}

% Helper to work around a problem with "#"s for URLs within \href
% within other macros:
\newcommand{\Shref}[3]{\href{#1\##2}{#3}}

% For URLs:
\newcommand{\Snolinkurl}[1]{\nolinkurl{#1}}

% History note:
\newcommand{\SHistory}[1]{\begin{smaller}#1\end{smaller}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Scribble then generates the following:
%
%  \begin{document}
%  \preDoc
%  \titleAndVersion{...}{...}
%  ... document content ...
%  \postDoc
%  \end{document}

\newcommand{\NoteBox}[1]{\footnote{#1}}
\newcommand{\NoteContent}[1]{#1}

\newcommand{\Footnote}[1]{\footnote{#1}}
\newcommand{\FootnoteRef}[1]{}
\newcommand{\FootnoteTarget}[1]{}
\newcommand{\FootnoteContent}[1]{#1}

% Redefine \noindent to avoid generating any output at all:
\newenvironment{FootnoteBlock}{\renewcommand{\noindent}{}}{}
\newcommand{\FootnoteBlockContent}[1]{}

% Redefine \SColorize to produce B&W Scheme text
\newcommand{\SColorize}[2]{\color{#1}{#2}}

% Redefine SHyphen to allow identifiers to be hyphenated
\newcommand{\SHyphen}[1]{#1}

\newcommand{\inColor}[2]{{\SHyphen{\Scribtexttt{\SColorize{#1}{#2}}}}}
\definecolor{PaleBlue}{rgb}{0.90,0.90,1.0}
\definecolor{LightGray}{rgb}{0.90,0.90,0.90}
\definecolor{CommentColor}{rgb}{0.76,0.45,0.12}
\definecolor{ParenColor}{rgb}{0.52,0.24,0.14}
\definecolor{IdentifierColor}{rgb}{0.15,0.15,0.50}
\definecolor{ResultColor}{rgb}{0.0,0.0,0.69}
\definecolor{ValueColor}{rgb}{0.13,0.55,0.13}
\definecolor{OutputColor}{rgb}{0.59,0.00,0.59}

\newcommand{\RktPlain}[1]{\inColor{black}{#1}}
\newcommand{\RktKw}[1]{{\SColorize{black}{\Scribtexttt{#1}}}} % no \textbf anymore
\newcommand{\RktStxLink}[1]{\RktKw{#1}}
\newcommand{\RktStxDef}[1]{\RktStxLink{#1}}
\newcommand{\RktCmt}[1]{\inColor{CommentColor}{#1}}
\newcommand{\RktPn}[1]{\inColor{ParenColor}{#1}}
\newcommand{\RktInBG}[1]{\inColor{ParenColor}{#1}}
\newcommand{\RktSym}[1]{\inColor{IdentifierColor}{#1}}
\newcommand{\RktSymDef}[1]{\RktSym{#1}}
\newcommand{\RktVal}[1]{\inColor{ValueColor}{#1}}
\newcommand{\RktValLink}[1]{\inColor{blue}{#1}}
\newcommand{\RktValDef}[1]{\RktValLink{#1}}
\newcommand{\RktModLink}[1]{\inColor{blue}{#1}}
\newcommand{\RktRes}[1]{\inColor{ResultColor}{#1}}
\newcommand{\RktOut}[1]{\inColor{OutputColor}{#1}}
\newcommand{\RktMeta}[1]{\inColor{IdentifierColor}{#1}}
\newcommand{\RktMod}[1]{\inColor{black}{#1}}
\newcommand{\RktRdr}[1]{\inColor{black}{#1}}
\newcommand{\RktVarCol}[1]{\inColor{IdentifierColor}{#1}}
\newcommand{\RktVar}[1]{{\RktVarCol{\textsl{#1}}}}
\newcommand{\RktErrCol}[1]{\inColor{red}{#1}}
\newcommand{\RktErr}[1]{{\RktErrCol{\textrm{\textit{#1}}}}}
\newcommand{\RktOpt}[1]{#1}
\newcommand{\RktIn}[1]{\incolorbox{LightGray}{\RktInBG{#1}}}
\newcommand{\highlighted}[1]{\colorbox{PaleBlue}{\hspace{-0.5ex}\RktInBG{#1}\hspace{-0.5ex}}}

\newenvironment{RktBlk}{}{}
\newenvironment{defmodule}{}{}
\newenvironment{prototype}{}{}
\newenvironment{argcontract}{}{}
\newenvironment{together}{}{}

\newenvironment{specgrammar}{}{}


\newenvironment{RBibliography}{}{}
\newcommand{\bibentry}[1]{\parbox[t]{0.8\linewidth}{#1}}

\newenvironment{leftindent}{\begin{quote}}{\end{quote}}
\newenvironment{insetpara}{\begin{quote}}{\end{quote}}

\newcommand{\Rfilebox}[2]{\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=0ex\rightmargin=0ex%
\itemsep=0pt\parsep=0pt}\item #1

#2\end{list}}
\newcommand{\RfileboxBox}[3]{#3{\halign{\hfil##\cr #1 \cr #2 \cr}}}
\newcommand{\RfileboxBoxT}[2]{\RfileboxBox{#1}{#2}{\vtop}}
\newcommand{\RfileboxBoxC}[2]{\RfileboxBox{#1}{#2}{\Svcenter}}
\newcommand{\RfileboxBoxB}[2]{\RfileboxBox{#1}{#2}{\vbox}}
\newcommand{\Rfiletitle}[1]{\hfill \fbox{#1}}
\newcommand{\RfiletitleBox}[1]{\fbox{#1}}
\newcommand{\Rfilename}[1]{#1}
\newenvironment{Rfilecontent}{}{}
\newcommand{\RfilecontentBox}[1]{#1}

\newcommand{\RBackgroundLabel}[1]{}
\newenvironment{RBackgroundLabelInner}{}{}

\newcommand{\RpackageSpec}[1]{\hspace{5ex} #1}
\usepackage{ccaption}

% \legend relies on \belowcaptionskip, which is not defined
% by the JFP class file:
\makeatletter
\@ifundefined{belowcaptionskip}{\newlength{\belowcaptionskip}}{}
\makeatother

\newcommand{\Legend}[1]{~

                        \hrule width \hsize height .33pt
                        \vspace{4pt}
                        \legend{#1}}

\newcommand{\LegendContinued}[1]{\Legend{#1}}

\newcommand{\FigureTarget}[2]{#1}
\newcommand{\FigureRef}[2]{#1}

\newlength{\FigOrigskip}
\FigOrigskip=\parskip

% Put this before the figure content, so that a hyperref goes to
% the start of the content:
\newcommand{\FigureSetRef}{\refstepcounter{figure}}

\newenvironment{Figure}{\begin{figure}\FigureSetRef}{\end{figure}}
\newenvironment{FigureMulti}{\begin{figure*}[t!p]\FigureSetRef}{\end{figure*}}
\newenvironment{FigureMultiWide}{\begin{FigureMulti}\FigureSetRef}{\end{FigureMulti}}
\newenvironment{Herefigure}{\begin{figure}[ht!]\FigureSetRef\centering}{\end{figure}}

\newenvironment{Centerfigure}{\begin{Xfigure}\centering\item}{\end{Xfigure}}
\newenvironment{Leftfigure}{\begin{Xfigure}\item}{\end{Xfigure}}
\newenvironment{Rightfigure}{\begin{Xfigure}\item}{\end{Xfigure}}

\newenvironment{Xfigure}{\begin{list}{}{\leftmargin=0pt\topsep=0pt\parsep=\FigOrigskip\partopsep=0pt}}{\end{list}}

\newenvironment{FigureInside}{}{}

\newcommand{\Centertext}[1]{\begin{center}#1\end{center}}


\def\texMath#1{#1}
\def\texMathInline#1{\ensuremath{#1}}
\def\texMathDisplay#1{\ifmmode #1\else\[#1\]\fi}% This style file is used both for `book' and `report' modes

\renewcommand{\ChapRef}[2]{chapter~#1}
\renewcommand{\ChapRefUC}[2]{Chapter~#1}

% sections
\renewcommand{\Spart}[2]{\part[#1]{#2}}
\renewcommand{\Ssection}[2]{\chapter[#1]{#2}}
\renewcommand{\Ssubsection}[2]{\section[#1]{#2}}
\renewcommand{\Ssubsubsection}[2]{\subsection[#1]{#2}}
\renewcommand{\Ssubsubsubsection}[2]{\subsubsection[#1]{#2}}
\renewcommand{\Ssubsubsubsubsection}[2]{{\bf #2}}

% "star" means unnumbered and not in ToC:
\renewcommand{\Spartstar}[1]{\part*{#1}}
\renewcommand{\Ssectionstar}[1]{\chapter*{#1}}
\renewcommand{\Ssubsectionstar}[1]{\section*{#1}}
\renewcommand{\Ssubsubsectionstar}[1]{\subsection*{#1}}
\renewcommand{\Ssubsubsubsectionstar}[1]{\subsubsection*{#1}}
\renewcommand{\Ssubsubsubsubsectionstar}[1]{\Ssubsubsubsubsection{#1}}

% "starx" means unnumbered but in ToC:
\renewcommand{\Spartstarx}[2]{\Spartstar{#2}\addcontentsline{toc}{part}{#1}}
\renewcommand{\Ssectionstarx}[2]{\Ssectionstar{#2}\addcontentsline{toc}{chapter}{#1}}
\renewcommand{\Ssubsectionstarx}[2]{\Ssubsectionstar{#2}\addcontentsline{toc}{section}{#1}}
\renewcommand{\Ssubsubsectionstarx}[2]{\Ssubsubsectionstar{#2}\addcontentsline{toc}{subsection}{#1}}
\renewcommand{\Ssubsubsubsectionstarx}[2]{\Ssubsubsubsectionstar{#2}\addcontentsline{toc}{subsubsection}{#1}}
\renewcommand{\Ssubsubsubsubsectionstarx}[2]{\Ssubsubsubsubsectionstar{#2}}

% "grouper" is for the 'grouper style variant:
\renewcommand{\Ssubsectiongrouper}[2]{\setcounter{GrouperTemp}{\value{section}}\Ssubsectionstarx{#1}{#2}\setcounter{section}{\value{GrouperTemp}}}
\renewcommand{\Ssubsubsectiongrouper}[2]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsubsectionstarx{#1}{#2}\setcounter{subsection}{\value{GrouperTemp}}}
\renewcommand{\Ssubsubsubsectiongrouper}[2]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstarx{#1}{#2}\setcounter{subsubsection}{\value{GrouperTemp}}}
\renewcommand{\Ssubsubsubsubsectiongrouper}[2]{\Ssubsubsubsubsectionstarx{#1}{#2}}

\renewcommand{\Ssubsectiongrouperstar}[1]{\setcounter{GrouperTemp}{\value{section}}\Ssubsectionstar{#1}\setcounter{section}{\value{GrouperTemp}}}
\renewcommand{\Ssubsubsectiongrouperstar}[1]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsubsectionstar{#1}\setcounter{subsection}{\value{GrouperTemp}}}
\renewcommand{\Ssubsubsubsectiongrouperstar}[1]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstar{#1}\setcounter{subsubsection}{\value{GrouperTemp}}}
\renewcommand{\Ssubsubsubsubsectiongrouperstar}[1]{\Ssubsubsubsubsectionstar{#1}}

% To increments section numbers:
\renewcommand{\Sincpart}{\stepcounter{part}}
\renewcommand{\Sincsection}{\stepcounter{chapter}}
\renewcommand{\Sincsubsection}{\stepcounter{section}}
\renewcommand{\Sincsubsubsection}{\stepcounter{subsection}}
\renewcommand{\Sincsubsubsubsection}{\stepcounter{subsubsection}}

\geometry{top=1.0in,bottom=1.0in,left=1.0in,right=1.0in}
\linespread{1.6}
\rmfamily
\fontsize{12}{2}

\begin{document}
\preDoc
\titleAndEmptyVersionAndAuthors{Programming Language Implementation}{}{\SNumberOfAuthors{1}\SAuthor{Charles Saternos}}
\label{t:x28part_x22Programmingx5fLanguagex5fImplementationx22x29}



\newpage \tableofcontents \newpage

\sectionNewpage

\Ssection{Introduction}{Introduction}\label{t:x28part_x22Introductionx22x29}

From the outside, programming languages seem like mystical entities that
somehow translate arcane instructions to tangible outputs. The inner
workings of these magical beasts are best left to those who have years of
research under their belt and advanced knowledge of computers.

While programming language implementations do draw on many areas of
computer science knowledge, simple programming language can easily be
developed by any hacker with moderate interest and some free time. In
fact, a simple meta{-}circular interpreter developed in Racket
(the language used for implementations in this book), could be written in
one sitting.

This book is meant to be an introduction to some of the concepts and
techniques used to build programming languages. We{'}ll be looking at simple
implementations, with runnable example code throughout the book. Most code
examples can be run on their own, and the reader is encouraged to run
them, particularly when they are confused. Tinkering with example code is
one of the best ways to learn new programming techniques.

For larger code examples that require multiple chunks of code, the book is
written using literate programming. Literate programming provides
a textual version of the code, meant for reading, as well as the option to
stitch the code chunks together into a runnable source file. This allows
the reader to check out the exact code they read in the chapter, change
it, and run it for themselves.

\Ssubsection{Book source}{Book source}\label{t:x28part_x22Bookx5fsourcex22x29}

The source for this whole book is available on GitHub
\href{https://github.com/charles-l/capstone}{\Snolinkurl{https://github.com/charles-l/capstone}}.
The reader is encouraged to download the source and run it for themself.

\Ssubsection{Why bother with programming language implementation?}{Why bother with programming language implementation?}\label{t:x28part_x22Whyx5fbotherx5fwithx5fprogrammingx5flanguagex5fimplementationx5fx22x29}

There are many reasons for learning how programming languages work under
the hood, but some of the most useful are gaining a deeper understanding
of what programming languages do, how to implement your own domain
specific languages, and building your own general purpose programming
languages for fun.

Gaining a comprehensive knowledge of compilers and interpreters gives you
the ability to reason about error messages, and tune the performance of
programs written in your your favorite programming language. For instance,
knowledge of how the C compiler works, gives a programmer the ability to
determine the difference between compile time and link time errors. When
they get a linker error, they{'}ll realize they forgot to include a library
or object file in their compilation command.

Performance tuning is also easier once a programmer knows how a programing
language is optimizing. For instance, in Lua, strings are interned
{-} they{'}re inserted into a large hash{-}table, so string comparisons are
cheap. This means the programmer doesn{'}t have to intern the strings in
a hash table by hand. Or in Python, knowing that the bytecode compiler
generates an opcode to create a dictionary directly for an inline
declaration (i.e. \Scribtexttt{{\char`\{}{\char`\}}}), and the \Scribtexttt{dict()} function does a function
call generates the opcode, meaning an inline \Scribtexttt{{\char`\{}{\char`\}}} is faster than
calling \Scribtexttt{dict()}.

\sectionNewpage

\Ssection{Background}{Background}\label{t:x28part_x22Backgroundx22x29}

This chapter will introduce the basics of the Racket programming language,
and will discuss some theory that will be used later during
implementation.

\Ssubsection{Racket}{Racket}\label{t:x28part_x22Racketx22x29}

\includegraphics[scale=0.5]{rkttmp98239c067a6552b13196269e9adf471433a234a1.png}

We{'}ll use the Racket programming language for the implementations
throughout the book. Racket is a descendent of Lisp, the second high{-}level
programming language created (after Fortran). Despite its age, Lisp
dialects are still popular today.

Racket is designed to aid programming language developers in prototyping
and experimenting with new programming language paradigms. It is a test
bed, with many tools and libraries that make implementations simple and
concise. Instead of tracking memory usage in C, or writing dozens of
classes in a complicated hierarchy in Java, we will focus on developing
compilers and interpreters using domain{-}specific languages provided by
Racket.

Even without the libraries and extra resources, Racket is still an
excellent choice for developing programming languages. With built{-}in
functional pattern matching, idiomatic use of recursion, which is useful
for tree{-}navigation, and a simple, easy{-}to{-}implement kernel
(which makes building Lisp interpreters trivial), Racket is a great choice
for language development.

Racket is a simple language that you can learned quickly. You{'}re
encouraged to enter the simple programs throughout this book to see the
results yourself. Fidget with them in a REPL
(the interactive prompt for Racket programs). Tweak
them and observe what changes in the output. You{'}re encouraged to copy the
code throughout the book, but it{'}s especially vital to understand this
chapter since concepts we introduce here are referenced throughout the book.

Lisp{'}s\NoteBox{\NoteContent{We{'}ll talk generally about Lisp and Scheme since the features
are relevant to Racket}} syntax is extremely minimal. Expressions are
written in prefix notation, with parentheses to denote function calls.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{println}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Hello}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{world"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{"Hello world"
}\end{SingleColumn}\end{SCodeFlow}

Literal values (i.e. strings, numbers, or booleans) and variables are
written without parentheses.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktVal{"reeeee"}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{"reeeee"}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktVal{2}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{2}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{the{-}number{-}three}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{the{-}number{-}three}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{3}\end{SingleColumn}\end{SCodeFlow}

The number of parentheses is significant in Lisp, unlike other languages
where they{'}re used for redefining order of operations. It{'}s nonsense to
write extra parentheses in many contexts.

For instance, the variable we defined in the previous example in another
pair of parentheses will attempt to execute the bound value (\Scribtexttt{3}) as
a function. This doesn{'}t make sense, so it{'}s important to match
parentheses carefully (a good editor is invaluable!).

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{the{-}number{-}three}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktErr{the{-}number{-}three: undefined;
 cannot reference an identifier before its definition
  in module: {\textquotesingle}anonymous{-}module
  context...:
   /usr/share/racket/collects/racket/private/more{-}scheme.rkt:148:2: call{-}with{-}break{-}parameterization
   .../more{-}scheme.rkt:261:28
   /usr/share/racket/pkgs/sandbox{-}lib/racket/sandbox.rkt:861:5: loop
}\end{SingleColumn}\end{SCodeFlow}

The DrRacet IDE that ships with Racket [\hyperref[t:x28cite_x22DrSchemex22x29]{DrScheme}] is a common choice
for newcomers to the language. DrRacket features a REPL
(read{-}eval{-}print{-}loop {-} a prompt for interactive program development),
a graphical debugger, and macro expander. It highlights and indents Racket
code properly, and generally makes life easier for users who aren{'}t
familiar with Lisp syntax and notation.

Lisp doesn{'}t (by default) have infix notation. Standard numeric operations
are written in prefix form. For example, 3 * (4 + 2) is written:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{*}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{4}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{18}\end{SingleColumn}\end{SCodeFlow}

This format seems awkward at first, but has the advantage of simple syntax
that is straightforward to parse which makes user defined macros possible
(which we{'}ll look at later).

Racket has standard data types (strings, numbers, and characters):

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktVal{"reeeee"}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{"reeeee"}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktVal{42}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{42}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktVal{\#{\char`\\}z}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{\#{\char`\\}z}\end{SingleColumn}\end{SCodeFlow}

And it has built{-}in data{-}types that are typically seen in Lisps. Namely
symbols, \Scribtexttt{cons} cells, lists, and vectors.

Symbols are similar to strings. The only distinction is the symbol{'}s value
is "interned" (i.e. inserted into an internal hash table), to make lookups
fast. This means symbols are cheap to compare, so they can be used in
contexts where enums would be used in other languages.

Symbols are created with the quote keyword:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{quote}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{symbols{-}are{-}cooler{-}than{-}strings}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}symbols{-}are{-}cooler{-}than{-}strings}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{println}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{quote}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{just{-}a{-}symbol}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{{\textquotesingle}just{-}a{-}symbol
}\end{SingleColumn}\end{SCodeFlow}

Since it{'}s awkward to keep write \Scribtexttt{quote} every time we create a symbol,
we can use the shorthand \Scribtexttt{}\Scribtexttt{{'}}\Scribtexttt{}.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{symbols{-}are{-}cooler{-}than{-}strings}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}symbols{-}are{-}cooler{-}than{-}strings}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{println}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{just{-}a{-}symbol}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{{\textquotesingle}just{-}a{-}symbol
}\end{SingleColumn}\end{SCodeFlow}

Admittedly, the quote syntax is shocking when seen by programmers who use
languages that use single quotes to denote characters or strings. But
quote shorthand is terser than the \Scribtexttt{quote} keyword, so we will use it.

Lisp{'}s primary container structure is the cons cell. A cons cell is a pair
of two values. The first and second elements of the pair are accessed with
the \Scribtexttt{car} and \Scribtexttt{cdr} functions respectively.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{b}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(a {\hbox{\texttt{.}}} b)}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"cool"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(2 {\hbox{\texttt{.}}} "cool")}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\}m}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\}e}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(\#{\char`\\}m {\hbox{\texttt{.}}} \#{\char`\\}e)}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{b}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}a}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{my{-}other{-}car{-}is}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{a{-}cdr}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}a{-}cdr}\end{SingleColumn}\end{SCodeFlow}

Cons cells can hold other cons cells in them, to become a linked list of
values.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{little}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{dotted}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{list}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(a little dotted {\hbox{\texttt{.}}} list)}\end{SingleColumn}\end{SCodeFlow}

Rather than storing a value in the last cons cell, it{'}s standard to store
the null list, \Scribtexttt{}\Scribtexttt{{'}}\Scribtexttt{()}, which helps simplify list navigation.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{proper}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{list}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(a proper list)}\end{SingleColumn}\end{SCodeFlow}

Since \Scribtexttt{cons}ing a bunch of \Scribtexttt{cons} cells together is tedious, the
helper function, \Scribtexttt{list} will create a linked{-}list of cons cells
(terminated by the empty list).

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{list}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{b}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{c}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(a b c)}\end{SingleColumn}\end{SCodeFlow}

Furthermore, quoting each individual element can become an annoyance, so
we can use the quote keyword to build a list of symbols.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{quote}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{b}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{c}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(a b c)}\end{SingleColumn}\end{SCodeFlow}

Or using the shorthand \Scribtexttt{}\Scribtexttt{{'}}\Scribtexttt{}:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{b}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{c}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(a b c)}\end{SingleColumn}\end{SCodeFlow}

The quote symbol can construct lists, sublists, and literal values.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktPn{(}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{b}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{c}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{d}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{e}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"strings}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{too{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}((a b c) d e f 1 2 3 "strings too{\hbox{\texttt{!}}}")}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktSym{working}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{with}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{lists}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{and}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{symbols}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{is}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{quite}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{nice}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(working with lists and symbols is quite nice)}\end{SingleColumn}\end{SCodeFlow}

And if you want to quote a list, but insert an expression or bound value
(i.e. a variable) instead of a literal quote, you can use the quasiquote
and unquote syntax.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{{\textasciigrave}}\RktPn{(}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{plus}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{is}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{,}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(1 plus 2 is 3)}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{{\textasciigrave}}\RktPn{(}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{is}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{,}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}((+ 1 2) is 3)}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{the{-}sum}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{{\textasciigrave}}\RktPn{(}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{is}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{,}\RktSym{the{-}sum}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}((+ 1 2) is 3)}\end{SingleColumn}\end{SCodeFlow}

Variable assignment (called variable binding in functional languages) is
possible in Racket with two mechanisms. The first is using the \Scribtexttt{define}
keyword (as shown before):

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}awesome{-}list}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{list}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{b}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{c}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}awesome{-}list}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}a}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}awesome{-}list}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(b c)}\end{SingleColumn}\end{SCodeFlow}

Racket{'}s \Scribtexttt{define} keyword operates like assignment in most
languages. The variable exists in the block or function it is defined in,
and is deleted once it goes out of scope.

The second way of defining variables is with a \Scribtexttt{let}
binding\NoteBox{\NoteContent{\Scribtexttt{let} bindings are more idiomatic in functional languages,
but Racket code usually uses the \Scribtexttt{define} keyword since it compiles to
a \Scribtexttt{let} binding anyway.}}. With a \Scribtexttt{let} binding the scope of the
variable can be explicitly defined with a block.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{let}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{y}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{y}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{5}\end{SingleColumn}\end{SCodeFlow}

After the ending parenthesis for the \Scribtexttt{let} block, the variable no
longer exists. Attempting to reference it results in an error:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{let}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{y}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{y}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{5}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{x}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktErr{x: undefined;
 cannot reference an identifier before its definition
  in module: {\textquotesingle}anonymous{-}module
  context...:
   /usr/share/racket/collects/racket/private/more{-}scheme.rkt:148:2: call{-}with{-}break{-}parameterization
   .../more{-}scheme.rkt:261:28
   /usr/share/racket/pkgs/sandbox{-}lib/racket/sandbox.rkt:861:5: loop
}\end{SingleColumn}\end{SCodeFlow}

Variations of \Scribtexttt{let} allow the programmer to specify whether bindings
can reference each other (\Scribtexttt{let*}), or reference themselves recursively
\Scribtexttt{letrec} (a useful feature for constructing recursive inner functions).

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{let*}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{y}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{y}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{6}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{letrec}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{y}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{c}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{y}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{c}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(a {\hbox{\texttt{.}}} 2)}\end{SingleColumn}\end{SCodeFlow}

Racket encourages the use of unnamed functions\NoteBox{\NoteContent{Called
\textit{anonymous functions}}} with the \Scribtexttt{lambda} keyword. A \Scribtexttt{lambda}
requires arguments and a body. To call the newly constructed \Scribtexttt{lambda},
wrap it in another set of parenthesis to apply it to the arguments you
pass.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{lambda}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{y}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{y}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{\#{\Stttextless}procedure{\Stttextmore}}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{lambda}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{y}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{y}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{4}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{6}\end{SingleColumn}\end{SCodeFlow}

Functions are first class values in Lisp, which means they can be passed
to another function like any primitive value or bound to a variable.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{lambda}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{5}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{letrec}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{make{-}bacon}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{lambda}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{n}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{cond}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{zero{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{n}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{else}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{bacon}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{make{-}bacon}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{\mbox{{-}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{n}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktMeta{}\RktPn{(}\RktSym{make{-}bacon}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{5}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(bacon bacon bacon bacon bacon)}\end{SingleColumn}\end{SCodeFlow}

In the previous example, you{'}ve seen the use of the \Scribtexttt{cond} keyword,
which operates like an bunch of \Scribtexttt{else if} statements. It starts with
the first condition \Scribtexttt{(zero{\hbox{\texttt{?}}} n)}, checks if the condition is true, and
executes the associated expression if the condition passes (i.e. it
returns \Scribtexttt{}\Scribtexttt{{'}}\Scribtexttt{()}). We can have more of these conditions, but in this code
we only ensure that \Scribtexttt{n} isn{'}t zero.

A larger \Scribtexttt{cond} example with boolean operators:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{categorize{-}character}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{lambda}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{has{-}staff}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{has{-}beard}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{has{-}hairy{-}feet}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{cond}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{and}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{has{-}staff}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{has{-}beard}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{wizard}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{and}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{has{-}hairy{-}feet}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{has{-}beard}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{dwarf}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktSym{has{-}hairy{-}feet}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{hobbit}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktSym{else}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{unknown}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{categorize{-}character}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#t}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#t}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#f}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}wizard}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{categorize{-}character}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#t}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}hobbit}\end{SingleColumn}\end{SCodeFlow}

\Scribtexttt{if} statements are in Racket, but require terse syntax. The first
expression in the if statement will run if the condition passes, otherwise
the second condition will execute.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{{\Stttextmore}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{8}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{println}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"8}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{is}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{greater}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{than}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{(+}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{2}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1)"}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{println}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"8}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{is}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{less}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{than}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{(+}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{2}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{which}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{obviously}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{isn{\textquotesingle}t}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{true"}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{"8 is greater than (+ 2 1)"
}\end{SingleColumn}\end{SCodeFlow}

Lisp heavily encourages recursion. Lisp can be defined without any looping
mechanisms built into the language since recursion can be used in place of it.

Cons cells are elegant when paired with recursion. Using the underlying
concept of pairs, its possible to recursively build and navigate complex
data structures like trees and lists with nothing but \Scribtexttt{car}, \Scribtexttt{car},
\Scribtexttt{lambda}s and \Scribtexttt{if} statements.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{append}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{lambda}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{b}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{null{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktMeta{}\RktSym{b}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{a}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{append}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{a}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{b}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{flatten{-}list}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{lambda}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{tree}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{null{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tree}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktSym{if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{list{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tree}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{append}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{flatten{-}list}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tree}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{flatten{-}list}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tree}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tree}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{flatten{-}list}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tree}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{flatten{-}list}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktPn{(}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{b}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{c}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{e}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{f}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(a b c e f)}\end{SingleColumn}\end{SCodeFlow}

We will not reimplement every utility function from scratch, but
remember these simple concepts since we will use cons{-}cells and lists
throughout this book. We will use libraries that come with Racket. The
documentation is readily available in the \Scribtexttt{Help {\Stttextmore} Documentation} menu
in DrRacket.

\Ssubsubsection{Macros}{Macros}\label{t:x28part_x22Macrosx22x29}

Consider the following \textit{list}.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(+ 2 3)}\end{SingleColumn}\end{SCodeFlow}

It{'}s data. It doesn{'}t actually calculate the value of 2 + 3, but it looks
eerily similar to the expression \Scribtexttt{(+ 1 2)} which will run.

Using the built in \Scribtexttt{eval} function, we can execute this data as code:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{eval}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{5}\end{SingleColumn}\end{SCodeFlow}

Using an unquote, we can cheekily capture surrounding variables.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{34}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{eval}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textasciigrave}}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{,}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{37}\end{SingleColumn}\end{SCodeFlow}

We can write code that generates code then evaluates it:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{list{-}downfrom}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cond}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{zero{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktVal{0}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{else}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{list{-}downfrom}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{\mbox{{-}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{list{-}downfrom}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{10}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(+ 10 9 8 7 6 5 4 3 2 1 0)}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{eval}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{list{-}downfrom}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{10}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{55}\end{SingleColumn}\end{SCodeFlow}

Using \Scribtexttt{eval} for demonstration purposes is fine, but its not meant for
regular use in code since it{'}s extremely unsafe. Besides security
vulnerabilities, \Scribtexttt{eval}s can capture surrounding bindings implicitly
leading to subtle bugs that are difficult to understand.

Don{'}t use \Scribtexttt{eval}.

But surrendering the powerful feature of code that generates code and
evaluates it would be regrettable. Consider how much boilerplate we might
eliminate, or the many interesting domain specific languages we might
create.

A key feature of Lisp is that it is \textit{homoiconicity}. Its syntax
\textit{is} a built{-}in data structure that can be easily manipulated. This
is why the data \Scribtexttt{}\Scribtexttt{{'}}\Scribtexttt{(+ 1 2)} looks like code that can be run.

Racket provides a \textit{hygienic macro system}\NoteBox{\NoteContent{Some Lisp
implementations implement unhygienic macros that allow the expanded syntax
to capture a variable bound in the surrounding context, which is unsafe
but sometimes useful.}} feature as a safe alternative to \Scribtexttt{eval}. Macros
match user defined syntax and expand it into an new form specified by the
programmer before running the code (i.e. at "compile{-}time").

A contrived example might be \Scribtexttt{inverse{-}if}, a feeble attempt at code obfuscation:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define{-}syntax}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{inverse{-}if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{stx}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{syntax{-}case}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{stx}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{inverse{-}if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{condition}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{else{-}expr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{then{-}expr}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktMeta{}\RktSym{\#{\textquotesingle}}\RktPn{(}\RktSym{if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{condition}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{then{-}expr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{else{-}expr}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{inverse{-}if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"IS}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{THIS}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{TRUE{\hbox{\texttt{?}}}"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"IS}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{THIS}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{FALSE{\hbox{\texttt{?}}}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{"IS THIS TRUE{\hbox{\texttt{?}}}"}\end{SingleColumn}\end{SCodeFlow}

\Ssubsubsection{Functional pattern \Scribtexttt{match}ing}{Functional pattern \Scribtexttt{match}ing}\label{t:x28part_x22Functionalx5fpatternx5fmatchingx22x29}

A common feature in functional languages is functional pattern matching.
Since a significant portion of conditional code navigates and operates on
data structures, functional languages implement a matching system that
allows the programmer to bind values that are nested within a structure.

Consider an association list, a Lisp data structure that stores key{-}value
pairs in \Scribtexttt{cons} cells and lists (similar to a hash table, albeit with poorer performance).
Association lists are slow to traverse if they{'}re large, but are
performant enough when they don{'}t store much data.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tasty{-}food}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktPn{(}\RktSym{crunchy}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{{\hbox{\texttt{.}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{peanut{-}butter}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{pulpy}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{{\hbox{\texttt{.}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{orange{-}juice}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{whole{-}grain}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{{\hbox{\texttt{.}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{bread}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}\end{SingleColumn}\end{SCodeFlow}

If we wanted to write a search function to traverse the association list,
we could use \Scribtexttt{car}s and \Scribtexttt{cdr}s to access data in the list.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{search}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{term}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{alist}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{null{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{alist}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktVal{\#f}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{eq{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{alist}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{term}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{alist}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktSym{search}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{term}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{alist}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{search}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{whole{-}grain}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tasty{-}food}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}bread}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{search}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{pulpy}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tasty{-}food}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}orange{-}juice}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{search}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{chocolate}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tasty{-}food}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{\#f}\end{SingleColumn}\end{SCodeFlow}

But wouldn{'}t it be nicer if the code looked like the data structure we
traverse?

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{matchy{-}search}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{term}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{alist}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{match}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{alist}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#f}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{{\textasciigrave}}\RktPn{(}\RktPn{(}\RktSym{,}\RktSym{key}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{{\hbox{\texttt{.}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{,}\RktSym{value}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{,}\RktSym{rest}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{if}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{eq{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{key}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{term}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxx}}}\RktMeta{}\RktSym{value}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{matchy{-}search}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{term}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{rest}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{matchy{-}search}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{whole{-}grain}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tasty{-}food}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}bread}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{matchy{-}search}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{caramel}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tasty{-}food}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{\#f}\end{SingleColumn}\end{SCodeFlow}

Functional pattern matching makes code easier to read since it cleanly
breaks up the code into cases. Each case plainly details the
structure of the data it is able to process. Code written with functional
pattern matching is easier to read and write, since the programmer can
instantly determine which cases are handled. Without functional pattern
matching, the programmer must mentally interpret the code{'}s execution to
discern which cases are handled.

\Ssubsection{Language semantics}{Language semantics}\label{t:x28part_x22Languagex5fsemanticsx22x29}

Every programming language has useful features and odd quarks, just like
spoken languages. Historically, programming languages have varied wildly
in syntax. Newer languages tend toward C{-}style or ALGOL{-}style syntax, but
older languages experimented with strange and arcane syntax that goes
against modern sensibilities.

However, syntax a surface level detail. Well formatted or "pretty looking"
code isn{'}t necessarily good code. While syntax may vary wildly between
languages, the \textit{semantics} (i.e. the "meaning" of the program) is
more importantly what differentiates programming languages.

Some important differences in semantics are discussed next.

\Ssubsubsection{The paradigms: functional vs imperative vs object{-}oriented}{The paradigms: functional vs imperative vs object{-}oriented}\label{t:x28part_x22Thex5fparadigmsx5fx5ffunctionalx5fvsx5fimperativex5fvsx5fobjectx2dorientedx22x29}

The major paradigms for programming languages are functional,
object{-}oriented (OO), and imperative. While other paradigms, such as
dataflow, logic, and concatenative exist, these smaller paradigms overlap
with others (for instance, a logic programming
library could be embedded in a functional language).

Imperative (or procedural) programming languages rely on mutation and
side{-}effects. Reassigning variables and destructively updating data structures
are examples of mutation, and are expected in imperative languages.
Imperative programming is popular for systems languages (e.g. C, C++,
Go and Rust), since it maps closely to how modern CPUs work. This makes
performance tuning more transparent. These types of languages tend to win
in programming languages benchmarks since they can easily be optimized for
real hardware.

The runtime speed does come at a cost. It takes more programmer time to
develop applications in imperative languages, and they tend to have more
bugs (since imperative code is harder to verify than functional). Recently,
imperative langauages have dropped in popularity since parallelizing
imperative programs can be difficult. As single{-}threaded performance for
CPUs plateaus (because of physical limitiations), parallelized
applications become more important.

Object{-}oriented programming utilizes imperative constructs inside objects.
Most object{-}oriented systems are graphs of objects that rely on mutation
and encapsulated state changes.

\begin{Figure}\begin{Centerfigure}\begin{FigureInside}\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{add{-}to{-}x{\hbox{\texttt{!}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktMeta{}\RktPn{(}\RktSym{set{\hbox{\texttt{!}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{add{-}to{-}x{\hbox{\texttt{!}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{print}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{2}\end{SingleColumn}\end{SCodeFlow}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22Imperative_code_examplex22x29x29}Figure~1: }{t:x28counter_x28x22figurex22_x22Imperative_code_examplex22x29x29}Racket tends to discourage imperative programming, more often opting for the
    functional paradigm. That{\textquotesingle}s why this code is a bit awkward}}\end{Figure}

\noindent \NoteBox{\NoteContent{Racket encourages the convention of postfixing an exclamation mark onto
code that does mutation}}

Object{-}oriented code focuses on keeping state data and functions that
change it together, in an attempt to mimic objects in the real world.
Perhaps we want to model a coffee machine with an object. Some relevant
state to track is whether it is turned on, how much water is in the water
chamber, or when the coffee was brewed. For functionality we{'}ll add the
ability to turn on the coffee maker, and use it to brew a pot of
coffee.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{coffeemaker{-}class\%}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{class}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{object\%}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{field}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cups{-}made}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{status}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{off}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{define/public}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{turn{-}on{\hbox{\texttt{!}}}}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{set{\hbox{\texttt{!}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{status}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{on}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{define/public}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{make{-}coffee{\hbox{\texttt{!}}}}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{when}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{eq{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{status}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{off}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{error}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Coffee}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{maker}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{must}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{be}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{turned}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{on}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{to}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{make}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{coffee"}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{set{\hbox{\texttt{!}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{cups{-}made}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{cups{-}made}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{define/public}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{turn{-}off{\hbox{\texttt{!}}}}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktSym{set{\hbox{\texttt{!}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{status}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{off}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{define/public}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{get{-}cups{-}made}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktSym{cups{-}made}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{super{-}new}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}coffeemaker}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{make{-}object}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{coffeemaker{-}class\%}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{send}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}coffeemaker}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{make{-}coffee{\hbox{\texttt{!}}}}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktErr{Coffee maker must be turned on to make coffee
  context...:
   str{-}w/{-}lang{-}$>$module{-}syntax:7:4: make{-}coffee! method in coffeemaker{-}class\%
   /usr/share/racket/collects/racket/private/more{-}scheme.rkt:148:2: call{-}with{-}break{-}parameterization
   .../more{-}scheme.rkt:261:28
   /usr/share/racket/pkgs/sandbox{-}lib/racket/sandbox.rkt:861:5: loop
}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{send}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}coffeemaker}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{turn{-}on{\hbox{\texttt{!}}}}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{send}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}coffeemaker}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{make{-}coffee{\hbox{\texttt{!}}}}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{send}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}coffeemaker}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{make{-}coffee{\hbox{\texttt{!}}}}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{send}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}coffeemaker}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{make{-}coffee{\hbox{\texttt{!}}}}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{send}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}coffeemaker}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{turn{-}off{\hbox{\texttt{!}}}}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{send}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{my{-}coffeemaker}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{get{-}cups{-}made}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{3}\end{SingleColumn}\end{SCodeFlow}

While the object{-}oriented model was popular in the 1990s, some of its
limitations have come to light recently. In particular, object{-}oriented
programming tends to lead to tightly{-}coupled components, that don{'}t
encourage reuse. Object oriented code is also notoriously difficult to
parallelize since it{'}s hard to reason about when variables will be
mutated.

Object{-}oriented programming might be useful sometimes, but it is a limited
model. It seems attractive at first but quickly becomes difficult to use.

The final paradigm we{'}ll discuss is functional programming. It is the
paradigm that will be used most in this book. In functional programming,
functions are defined in the mathematical sense. They{'}re \textit{pure},
which means they only have inputs and outputs without ever mutating
values.

For instance, a function that appends an element onto a list would be
written so it constructed an entirely \textit{new} list from scratch with
the new element appended onto the end. Purely functional languages force
immutability, meaning it{'}s invalid to ever mutate a value. This tends to
result in code that is easy to reason about, since implicit state isn{'}t
a factor to consider. Functional programming is superior to
object{-}oriented programming from a code reuse standpoint, since functional
composition is encouraged and tends to work better than complex class
hierarchies. It results in small, general functions that work well
together.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{l}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{b}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{c}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{d}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{e}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{f}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{append}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{l}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{x}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(a b c d e f {\hbox{\texttt{.}}} x)}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{l}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(a b c d e f)}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{j}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{4}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{5}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{6}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{map}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{add1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{j}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(2 3 4 5 6 7)}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktSym{j}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(1 2 3 4 5 6)}\end{SingleColumn}\end{SCodeFlow}

Functional programming does have limitations. For instance, functional
code that manages state can be confusing for a beginner since state
updates often simulated with recursion and monads. However, many
programs don{'}t need implicit state, and can be rewritten as a series of
functions chained together in a pipeline. Pipelines are easy to
understand and reuse.

\Ssubsubsection{When are types enforced? Static vs dynamic typing}{When are types enforced? Static vs dynamic typing}\label{t:x28part_x22Whenx5farex5ftypesx5fenforcedx5fx5fStaticx5fvsx5fdynamicx5ftypingx22x29}

\begin{Figure}\begin{Centerfigure}\begin{FigureInside}\raisebox{-0.19999999999998863bp}{\makebox[320.00000000000006bp][l]{\includegraphics[trim=2.4000000000000004 2.4000000000000004 2.4000000000000004 2.4000000000000004]{pict.pdf}}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22Code_continuumx22x29x29}Figure~2: }{t:x28counter_x28x22figurex22_x22Code_continuumx22x29x29}Continuum of dynamic/static, weak/strong type systems}}\end{Figure}

Choosing between static and dynamic typing is a decision between safety
and flexibility. With dynamic type systems, variables point to values that
track their own type information. This means variables can be
reassigned to different types, and functions aren{'}t guaranteed to return
a specific type. This makes code easier to write quickly, but harder to
reason about (especially in a formal manner). Since it{'}s difficult or
sometimes impossible to determine types statically (i.e. at compile time),
the programmer can{'}t always guarantee that the program won{'}t crash on
a type mismatch error at runtime.

In the following example, types are \textit{not} checked at compile time.
The predicates \Scribtexttt{number{\hbox{\texttt{?}}}} and \Scribtexttt{string{\hbox{\texttt{?}}}} operate on tagged runtime
values.

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktModLink{\RktMod{\#lang}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktModLink{\RktSym{racket}}\RktMeta{}\end{SingleColumn}\end{RktBlk}

\noindent \begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{cond}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{number{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktMeta{}\RktPn{(}\RktSym{add1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{string{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktMeta{}\RktPn{(}\RktSym{string{-}append}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{($\geq$$\nabla$$\leq$)/"}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{else}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{3}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"dynamic}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{typing}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{is}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{freedom{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{"dynamic typing is freedom{\hbox{\texttt{!}}} ($\geq$$\nabla$$\leq$)/"}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktSym{no}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{one}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{expects}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{LIST{\hbox{\texttt{!}}}}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(no one expects a LIST{\hbox{\texttt{!}}})}\end{SingleColumn}\end{SCodeFlow}

Given an arbitrary \Scribtexttt{x} of an unknown type, we{'}re unsure of the type of
the return value of \Scribtexttt{f}. For quick prototyping and non{-}mission{-}critical
code, dynamic types are convenient and easy to work with. However, once
a system grows, the uncertainty from dynamic types makes debugging and
maintenance hard. There{'}s no easy way to prove the system works without
running massive test suites (and still there are no guarantees).

In comparison, static typing \textit{requires} the programmer to notate type
information for functions and variables. Then, the type system can prove
correctness about types \textit{at compile time} and ensure that types are
handled consistently even for edge cases.

In this \Scribtexttt{typed/racket} example, we force the type of \Scribtexttt{x} to be
a real number. Attempting to pass a string instead, will result in
a compile{-}time error.

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktModLink{\RktMod{\#lang}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktModLink{\RktSym{typed/racket}}\RktMeta{}\end{SingleColumn}\end{RktBlk}

\noindent \begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{{\hbox{\texttt{:}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{\mbox{{-}{\Stttextmore}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{Real}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{Real}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{add1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{x}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{{-} {\hbox{\texttt{:}}} Real
}

\RktRes{3}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"static}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{typing}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{makes}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{code}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{safe{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktErr{str{-}w/{-}lang{-}$>$module{-}syntax:7:3: Type Checker: type mismatch
  expected: Real
  given: String
  in: "static typing makes code safe!"
  context...:
   /usr/share/racket/pkgs/typed{-}racket{-}lib/typed{-}racket/typecheck/check{-}below.rkt:110:5: perform{-}check!
   ...t/private/kw.rkt:764:9
   parse{-}loop494
   fail{-}handler867
   fail{-}handler102
   /usr/share/racket/pkgs/typed{-}racket{-}lib/typed{-}racket/typecheck/tc{-}expr{-}unit.rkt:78:0: core87
   /usr/share/racket/pkgs/typed{-}racket{-}lib/typed{-}racket/typecheck/tc{-}toplevel.rkt:599:0: tc{-}toplevel{-}form
   fail{-}handler46
   /usr/share/racket/collects/racket/private/more{-}scheme.rkt:148:2: call{-}with{-}break{-}parameterization
   .../more{-}scheme.rkt:261:28
   /usr/share/racket/pkgs/sandbox{-}lib/racket/sandbox.rkt:861:5: loop
}\end{SingleColumn}\end{SCodeFlow}

Since the types are explicitly defined by the programmer, there{'}s little
room for ambiguity. In cases where a programmer wants to define a function
that can operate on multiple data{-}types more generally, polymorphic types
can be used.

For instance, if we define an append function (named \Scribtexttt{tappend} since
\Scribtexttt{append} is already defined by Racket) to operate on a list, we
must define the type of the list.

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktModLink{\RktMod{\#lang}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktModLink{\RktSym{typed/racket}}\RktMeta{}\end{SingleColumn}\end{RktBlk}

\noindent \begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{{\hbox{\texttt{:}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tappend}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{\mbox{{-}{\Stttextmore}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{Listof}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{Integer}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{Integer}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{Listof}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{Integer}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{tappend}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{l}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{cond}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{null{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{l}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{list}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{else}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{l}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{tappend}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{l}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{tappend}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{4}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{{-} {\hbox{\texttt{:}}} (Listof Integer)
}

\RktRes{{\textquotesingle}(1 2 3 4)}\end{SingleColumn}\end{SCodeFlow}

This function only operates on lists of numbers, so we{'}d have to redefine
it for every possible datatype and duplicate the code. Instead of
specifying the exact type the list{'}s contents, we can specify
a polymorphic function that accepts lists that contain any type.

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktModLink{\RktMod{\#lang}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktModLink{\RktSym{typed/racket}}\RktMeta{}\end{SingleColumn}\end{RktBlk}

\noindent \begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{{\hbox{\texttt{:}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{tappend}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{All}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{A}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{\mbox{{-}{\Stttextmore}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{Listof}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{A}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{A}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{Listof}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{A}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{tappend}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{l}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{cond}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{null{\hbox{\texttt{?}}}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{l}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{list}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktSym{else}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{l}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{tappend}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{l}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{tappend}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{4}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{{-} {\hbox{\texttt{:}}} (Listof Positive{-}Byte)
}

\RktRes{{\textquotesingle}(1 2 3 4)}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{tappend}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktSym{a}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{b}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{c}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{d}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{{-} {\hbox{\texttt{:}}} (Listof (U {\textquotesingle}a {\textquotesingle}b {\textquotesingle}c {\textquotesingle}d))
}

\RktRes{{\textquotesingle}(a b c d)}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{tappend}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktPn{(}\RktVal{"d"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"o"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"o"}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"d"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{{-} {\hbox{\texttt{:}}} (Listof String)
}

\RktRes{{\textquotesingle}("d" "o" "o" "d")}\end{SingleColumn}\end{SCodeFlow}

Besides safety, static typing allows the compiler to perform more
optimizations since it can knows the types of the values and doesn{'}t need
to check them at runtime. The resulting code can then has less overhead
due to type checks.

With Racket, we can have the best of both worlds, since code that is
written in \Scribtexttt{racket/static} is compatible with regular Racket code. We
can quickly prototype, then tighten up our code with types later.

\Ssubsubsection{Should the compiler typecast for you? Strong vs weak
typing}{Should the compiler typecast for you? Strong vs weak
typing}\label{t:x28part_x22Shouldx5fthex5fcompilerx5ftypecastx5fforx5fyoux5fx5fStrongx5fvsx5fweakx5ftypingx22x29}

The other axis that must be considered is strong vs weak types. Weak
typing is more "forgiving" in the sense that the language will
automatically cast values to prevent type errors. This may be considered
a convenience, but it can also lead to subtle bugs where unexpected type
coercion results in an incorrect type.

Most modern languages, particularly static languages, tend towards
a stronger type system. Arguably, the most popular language that is weakly
typed is C. It was originally designed for operating systems, which
require unsafe code. In C, any type can be cast to any other, and often
types are implicitly cast silently or with just a warning. There aren{'}t
many rules for type casts in C. For instance, a floating point value could
be cast to a string pointer, then dereferenced. This series of
ridiculously unsafe operations may be correct in some context, but it is
difficult to prove the correctness.

Most scripting languages are more stringent about type coercion (e.g. they
won{'}t allow addition to be performed on a number and a string). Some allow
implicit casting between integer and floating point numbers, but don{'}t
take it farther than that. A notable deviation from this is
JavaScript. For instance, it will attempt to cast anything (even a function!)
to a string if a concatenation operation is attempted between a string and
any other value.

\Ssubsubsection{What{'}s the order of evaluation? Lazy vs strict evaluation}{What{'}s the order of evaluation? Lazy vs strict evaluation}\label{t:x28part_x22Whatx5fsx5fthex5forderx5fofx5fevaluationx5fx5fLazyx5fvsx5fstrictx5fevaluationx22x29}

\textit{Strict evaluation} evaluates all sub{-}expressions in an expression
before evaluating the top{-}level expression itself. For instance, with
strict evaluation the expression \Scribtexttt{(a (b c) (d e))} would evaluate
\Scribtexttt{(b c)} and \Scribtexttt{(d e)}, then \Scribtexttt{(a {\Stttextless}the result of (b c){\Stttextmore} {\Stttextless}the result of (d e){\Stttextmore})}.
With lazy evaluation, the expressions \Scribtexttt{(b c)} and \Scribtexttt{(d e)} would only
be evaluated if \Scribtexttt{a} referenced the value at some point.

Lazy evaluation waits until the last possible moment to execute
sub{-}expressions. If the value is never used, it is never evaluated. Most
languages have strict evaluation, but certain features, such as boolean
operators, are often lazily evaluated
(though usually its called short{-}circuiting in the context of boolean operators).

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktModLink{\RktMod{\#lang}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktModLink{\RktSym{racket}}\RktMeta{}\end{SingleColumn}\end{RktBlk}

\noindent \begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{false{-}fun}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{print}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"YOU{\textquotesingle}VE}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{BEEN}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{TERMINATED"}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{newline}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktVal{\#f}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{true{-}fun}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{print}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"continue{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}"}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{newline}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktVal{\#t}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{and}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{false{-}fun}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{true{-}fun}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{true{-}fun}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{"YOU{\textquotesingle}VE BEEN TERMINATED"
}

\RktRes{\#f}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{and}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{true{-}fun}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{false{-}fun}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{true{-}fun}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{"continue{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}"
"YOU{\textquotesingle}VE BEEN TERMINATED"
}

\RktRes{\#f}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{and}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{true{-}fun}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{true{-}fun}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{false{-}fun}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{"continue{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}"
"continue{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}"
"YOU{\textquotesingle}VE BEEN TERMINATED"
}

\RktRes{\#f}\end{SingleColumn}\end{SCodeFlow}

As soon as a condition fails, the \Scribtexttt{and} stops evaluating, which is a lazy way
of checking results. In languages with lazy evaluation, \textit{every} function operates this
way (i.e. it doesn{'}t compute the argument until it needs the value), which
allows for some interesting constructs that aren{'}t possible with strict
evaluation.

For instance, with strict evaluation, the following recursive function
would loop forever since there{'}s no base condition to terminate it.

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktModLink{\RktMod{\#lang}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktModLink{\RktSym{racket}}\RktMeta{}\end{SingleColumn}\end{RktBlk}

\noindent \begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{dont{-}stop{-}believing}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{hold{-}on{-}to{-}that{-}feeeeeeling}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{dont{-}stop{-}believing}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}\end{SingleColumn}\end{SCodeFlow}

However, with Racket{'}s \Scribtexttt{lazy} language implementation (that does lazy
                                                               evaluation),
this code will operate as a lazy stream
(which doesn{'}t compute the whole array, and only computes each value as it
       is needed). Therefore, we can represent infinite data structures.

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktModLink{\RktMod{\#lang}}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktModLink{\RktSym{lazy}}\RktMeta{}\end{SingleColumn}\end{RktBlk}

\noindent \begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{dont{-}stop{-}believing}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{cons}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{hold{-}on{-}to{-}that{-}feeeeeeling}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{dont{-}stop{-}believing}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{dont{-}stop{-}believing}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}hold{-}on{-}to{-}that{-}feeeeeeling}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{car}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{dont{-}stop{-}believing}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}hold{-}on{-}to{-}that{-}feeeeeeling}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{cdr}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{dont{-}stop{-}believing}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(hold{-}on{-}to{-}that{-}feeeeeeling {\hbox{\texttt{.}}} \#{\Stttextless}promise{\hbox{\texttt{:}}}temp2{\Stttextmore})}\end{SingleColumn}\end{SCodeFlow}

Looking at the last result, we can see it creates
a \textit{promise}, which delays the evaluation of the results until the
value is "forced" (i.e. evaluated) once its value is needed.

Lazy evaluation doesn{'}t cooperate with side{-}effects, since an argument
might change part way through a functions evaluation. Lazy evaluation
isn{'}t seen often besides an occasional purely functional language like
Haskell, or as an addon for languages that heavily encourage the
functional paradigm (like Scheme and OCaml).

\Ssubsection{Lambda calculus}{Lambda calculus}\label{t:x28part_x22Lambdax5fcalculusx22x29}

When discussing programming language theory, its useful to define
a minimal model that can perform any computation. The first and most
common model used is the Turing machine, which is a useful model because
it maps closely to real hardware.

A Turing machine consists of a finite state machine\NoteBox{\NoteContent{Which is a graph
of the control flow of the program, much like the IR for a compiler.}}, and
a tape reader that can read, write and shift around an infinite tape. Real
CPUs execute lists of instructions with jumps (that a finite state machine
can model), and memory is similar to a tape that doesn{'}t require shifting
to cells.

Using this minimal model for computability can lead to some interesting
designs. For instance, HTML5 and CSS3 (without JavaScript),
C++ templates (which were made Turing complete by accident), Magic: The
Gathering (the card game), Minecraft, Excel formulas, and a plethora of
other systems are accidentally Turing complete \NoteBox{\NoteContent{That is to say, they
meet the requirements for a Turing machine}}. This means that \textit{any}
computable problem
(i.e. any problem that can be solved with a real computer and a general
      purpose programming language), can be solved with any of these
Turing complete systems. You could calculate the Fibonacci sequence with
Magic the Gathering, or compute a frame of Doom with an Excel spreadsheet.
You could emulate an NES game with just C++ templates, and do matrix
multiplication with CSS3 rules.

Obviously, these examples are contrived, and it wouldn{'}t make sense to use
these systems for a real computation. They{'}re not meant for
general purpose computing so they{'}re slow and difficult to use to solve
these problems. However, it is useful to know the minimum requirements to
make a system Turing complete, since you can develop a way of computing
a desired value from first principles.

The Turing machine model is useful for modeling simple, real{-}world
computers. However, it isn{'}t good for representing functional programming
languages since they don{'}t focus on memory allocation in a tape, and often
represent function as first{-}class values which is awkward to represent in
a Turing machine. Instead of Turing machines, we will be using Lambda ($\lambda$)
Calculus (a model invented by Alonzo Church in the 1930s), to reason about
computation[\hyperref[t:x28cite_x22Churchx2c_1932x22x29]{Church, 1932}]. Lisp was based on $\lambda${-}calculus, so we will
use Lisp examples to demonstrate certain $\lambda${-}calculus concepts.

In $\lambda${-}calculus notation, function definitions are represented with the
$\lambda$ symbol and function applications are written in prefix notation (like
Lisp). For example, the Lisp function:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{lambda}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{i}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{+}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{32}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{\#{\Stttextless}procedure{\Stttextmore}}\end{SingleColumn}\end{SCodeFlow}

Would be notated in $\lambda${-}calculus as,

\texMathDisplay{\lambda i \; . \; + \; 32 \; i}

Parentheses are included for to clearly delimit expressions.
In particular, they{'}re useful for clearly notating applications\NoteBox{\NoteContent{We
will use the term \textit{function application} and \textit{function call}
interchangeably}}. For instance:

\texMathDisplay{(\lambda i \; . \; + \; 32 \; i) \; 2}

Which \textit{reduces} (or evaluates) to:

\texMathDisplay{(\lambda i \; . \; + \; 32 \; i) \; 2 \rightarrow \; (+ \; 32 \; 2) \rightarrow 34}

The \texMathInline{\rightarrow} denotes a single{-}step evaluation

To make our notation easier to understand, we{'}ll allow function
definitions through the \Scribtexttt{=} symbol. It is possible to represent
recursion with just anonymous functions using the Y{-}combinator
(a great description of which can be found in [\hyperref[t:x28cite_x22The_Little_Schemerx22x29]{The Little Schemer}]),
but we{'}ll allow function definitions to simplify our notation
(since it{'}s clearer).

In our previous examples, we{'}ve used operators (like \texMathInline{+}), and data
types like numbers in our functions, but $\lambda${-}calculus doesn{'}t necessarily
require numbers, standard mathematical operators, lists, or any kind of
data types besides functions. Functions can encode data with Church
Encoding [\hyperref[t:x28cite_x22Types_and_PLx22x29]{Types and PL}]. Once again, for pragmatic reasons, we will
extend $\lambda${-}calculus to include common data types like numbers, strings, and
booleans. We will also assume common operations on these data types.

\Ssubsubsection{Multiple arguments and currying}{Multiple arguments and currying}\label{t:x28part_x22Multiplex5fargumentsx5fandx5fcurryingx22x29}

We can represent multiple arguments in $\lambda${-}calculus by returning a new
function for every argument. For instance, if we wanted to write
a function to add three arguments together, we might write:

\texMathDisplay{\lambda a \; . \; \lambda b \; . \; \lambda c \; . \; (+ \; a \; b \; c)}

And to evaluate it, we evaluate each intermediate function until we the
final third function that adds the arguments.

\texMathDisplay{((((\lambda a \; . \; \lambda b \; . \; \lambda c \; . \; (+ \; a \; b \; c)) 1) 2) 3) \rightarrow}
\texMathDisplay{((\lambda b \; . \; \lambda c \; . \; (+ \; 1 \; b \; c) 2) 3) \rightarrow}
\texMathDisplay{(\lambda c \; . \; (+ \; 1 \; 2 \; c) 3) \rightarrow}
\texMathDisplay{(+ \; 1 \; 2 \; 3) \rightarrow 6}

After each of the first three steps of evaluation, the function reduces to
a new function with the innermost reference to the variable bound to the
argument that was passed. We can take advantage of these "partial
applications" to generate functions that store part of a computation, but
still require more arguments to fully compute the final value.

For instance, consider a string concatenate function (called \Scribtexttt{concat}).

\texMathDisplay{\texttt{concat} \; \texttt{"a"} \; \texttt{"b"} \rightarrow \texttt{"ab"}}

If we wanted to create a function called \Scribtexttt{suffix}, that concatenates
a string (\Scribtexttt{s}) onto the suffix (\Scribtexttt{u}).

\texMathDisplay{\texttt{suffix} = \lambda u \; . \; \lambda s \; . \; \texttt{concat} \; s \; u}

We can partially apply this function to create an \Scribtexttt{excited} function
that concatenates an exclamation point onto a string it is passed.

\texMathDisplay{\texttt{excited} = ((\texttt{suffix} \; \texttt{"!"}) \rightarrow (\lambda u \; . \; \lambda s \; . \;
\texttt{concat} \; s \; u) \; \texttt{"!"} \rightarrow \lambda s \; . \; \texttt{concat} \; s \; \texttt{"!"})}

We can apply \Scribtexttt{excited} to any string and the function will append the
explanation point.

\texMathDisplay{\texttt{excited} \; \texttt{"currying is cool"} \rightarrow}
\texMathDisplay{(\lambda s \; . \; \texttt{concat} \; s \; \texttt{"!"}) \; \texttt{"currying is cool"} \rightarrow}
\texMathDisplay{\texttt{concat} \; \texttt{"currying is cool"} \; \texttt{"!"} \rightarrow \texttt{"currying is cool!"}}

Currying is possible in Racket using the \Scribtexttt{curry} function.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{suffix}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{suf}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{str}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktSym{string{-}append}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{str}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{suf}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{define}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{excited}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{curry}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{suffix}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"{\hbox{\texttt{!}}}"}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{excited}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"currying}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{is}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{cool"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{"currying is cool{\hbox{\texttt{!}}}"}\end{SingleColumn}\end{SCodeFlow}

\Ssubsubsection{Function composition}{Function composition}\label{t:x28part_x22Functionx5fcompositionx22x29}

Nested function calls are prevalent in functional programming, which can
lead to busy{-}looking code.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{g}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{h}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{i}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktSym{j}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{a{-}value}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}some{-}transformed{-}value}\end{SingleColumn}\end{SCodeFlow}

To simplify the notation for this type of nesting, we{'}ll use the compose
operator to create a new function that applies each of the functions from
right to left (because of the order that results from nesting). So the
above code is equivalent to the following:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktPn{(}\RktSym{compose}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{f}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{g}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{h}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{i}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{j}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktSym{{\textquotesingle}}\RktSym{a{-}value}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}some{-}transformed{-}value}\end{SingleColumn}\end{SCodeFlow}

The compose operator originates in math, and is notated like so:

\texMathDisplay{f \circ g \circ h \circ i \circ j}

Programming purely through function composition is called
\textit{point{-}free programming}, and has the advantage of fewer named
variables which can make code easier to read and understand. Naming
variables is a difficult task, and a poorly named variable can confuse
a reader, so removing intermediate variables eliminates the issue.

\sectionNewpage

\Ssection{Parsing}{Parsing}\label{t:x28part_x22Parsingx22x29}

Like spoken languages, programming languages have a grammar. However,
human languages aren{'}t strict in their rules and are full of exceptions
and contextual cues. This is why natural language processing is a hard
problem, and why computers aren{'}t programmed in English.

For instance, the following English sentence is ambigious:

"Time flies like an arrow; fruit flies like a banana."

Does the phrase "fruit flies" refer to a collection of insects? If so,
then we{'}re saying that a specific family of insects enjoy a banana.
However, if "fruit flies like a banana" means pieces of fruit move through
the air similarly to a thrown banana, that{'}s an entirely different
meaning.

The reason a programming language is "understood" and executed by the
mindless machine is because it is described in a (usually
context{-}free) formal grammar. The formal grammars that language designers
use to describe the syntax for a grammar can unambiguously be "parsed."

The first step taken by any interpretor or compiler is the parsing step.
Parsing converts the plain{-}text source code into IR (intermediate
representation) {-} a tree (referred to as the \textit{parse tree}). The
parse tree is passed on to later compilation passes for semantic analysis,
interpretation or code generation, and other transformations.

Of course the parser needs a grammatically valid source file, so in
translating the source to a parse tree, it checks the syntax of the input.
If the syntax is invalid, it can emit a syntax error and fail, or attempt
to continue parsing the rest of the file if it{'}s possible.

There are many ways to implement a parser, but in this book we{'}ll cover
two:

\begin{itemize}\atItemizeStart

\item A \Scribtexttt{lex}/\Scribtexttt{yacc} parser

\item A parser combinator\end{itemize}

\Ssubsection{Formal languages}{Formal languages}\label{t:x28part_x22Formalx5flanguagesx22x29}

Formal languages are sets of strings that are made of words that are
generated by an alphabet [\hyperref[t:x28cite_x22Appelx2c_1998x22x29]{Appel, 1998}]. A language has an
associated grammar that defines the rules for constructing a valid (or
\textit{well{-}formed}) string in the language. Formal languages are
concerned purely with syntax (i.e. how sentences are constructed) not
semantics (i.e. what the sentences mean).

A grammar can be defined through a series of rules, which can then be
translated to a parser implementation. In the Chomsky hierarchy
[\hyperref[t:x28cite_x22Chomskyx2c_1956x22x29]{Chomsky, 1956}] the sophistication of the language and its
implementation increases with every level (\hyperref[t:x28counter_x28x22figurex22_x22chx22x29x29]{figure~\FigureRef{3}{t:x28counter_x28x22figurex22_x22chx22x29x29}}).

\begin{Figure}\begin{Centerfigure}\begin{FigureInside}\includegraphics[scale=0.5]{rkttmp04099a267f35f7d3c7d91c283df59f4a9861735d.png}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22chx22x29x29}Figure~3: }{t:x28counter_x28x22figurex22_x22chx22x29x29}The Chomsky hierarchy}}\end{Figure}

The simplest type of language, the regular language (also known as
a regular expression) can be defined with a restricted grammar that can be
modeled as a finite state machine. A finite state machine is simple to
implement which is appealing, but regular expressions cannot parse most
programming languages. They{'}re usually used for simple pattern matching on
strings (which makes them useful for parts of a parser like the lexing stage).

The next level, a context{-}free language, has more complex grammar and can
be modeled with a finite{-}state machine and a stack. Programming language
grammars are defined to be context{-}free, so syntax can be more expressive
without requiring the more sophisticated parsing algorithms for
the languages higher in the Chomsky hierarchy.

Context{-}sensitive languages can be parsed with a restricted Turing machine
and a recursively{-}enumerable language can be parsed with a full Turing
machine. Recursively{-}enumerable grammars can model human language, since
they have no restrictions on how grammars are constructed.

A context free grammar can be defined using a series of rules called
productions. Each production \textit{derives} a \textit{terminal} or
a \textit{non{-}terminal}. Terminals are the leafs of the derived tree, and
cannot be derived any further, while non{-}terminals have an associated
production rule allows them to be further derived. When notating grammer,
terminals are lowercase, and non{-}terminals are capitalized.

The symbol $\varepsilon$ is used to notate an empty word, and the vertical bar means
either the rule on the left of the bar or the rule on the right of the bar
can be applied. The derivation starts with the starting symbol \Scribtexttt{S}.

Using these rules, we can create a grammar that generates palindromes
in the alphabet \Scribtexttt{{\char`\{}a, b{\char`\}}}.

\hspace*{\fill}\\\Scribtexttt{S {-}{\Stttextmore} aSa {\Stttextbar} bSb {\Stttextbar} a {\Stttextbar} b {\Stttextbar} $\varepsilon$}\hspace*{\fill}\\

Using this grammar, if we wanted to generate the string \Scribtexttt{aba}, we would
derive it as,

\Scribtexttt{S {-}{\Stttextmore} aSa {-}{\Stttextmore} aba}

To generate \Scribtexttt{aabbaa},

\Scribtexttt{S {-}{\Stttextmore} aSa {-}{\Stttextmore} aaSaa {-}{\Stttextmore} aabSbaa {-}{\Stttextmore} aab$\varepsilon$baa = aabbaa}

A more sophisticated example might be to define a language with an
alphabet \Scribtexttt{{\char`\{}a, b, c{\char`\}}}. Each string our language must have an equal
number of \Scribtexttt{a}s and \Scribtexttt{b}s followed by any number of \Scribtexttt{c}s.

\hspace*{\fill}\\\Scribtexttt{S {-}{\Stttextmore} AB}\hspace*{\fill}\\\Scribtexttt{A {-}{\Stttextmore} aAb {\Stttextbar} $\varepsilon$}\hspace*{\fill}\\\Scribtexttt{B {-}{\Stttextmore} Bc {\Stttextbar} $\varepsilon$}\hspace*{\fill}\\

To generate \Scribtexttt{aaabbbc} we could derive it as follows,

\Scribtexttt{S {-}{\Stttextmore} AB {-}{\Stttextmore} aAbB {-}{\Stttextmore} aaAbbB {-}{\Stttextmore} aaaAbbbB {-}{\Stttextmore} aaa$\varepsilon$bbbB = aaabbbB {-}{\Stttextmore} aaabbbBc {-}{\Stttextmore} aaabbb$\varepsilon$c = aaabbbc}

\Ssubsection{Lexing}{Lexing}\label{t:x28part_x22Lexingx22x29}

Lexing is the step that "tokenizes" the input source code. The
tokenisation process splits the source into a set of words, each with an
associated type (e.g. keywords, numbers, and identifiers). One of the goals
of lexing is to removes non{-}semantic whitespace from the code, so any
spurious spaces, tabs or newlines are ignored by later passes. This can
simplify the parsing rules.

For instance, consider a string such as:

"It does not do to leave a live dragon out of your calculations, if you live near him"

We could use spaces as a delimiter for words, and we could assign the
nouns that are magical beasts with a special {`}MAGICAL{-}BEAST{`} tag.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{require}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{racket/match}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{require}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{racket/string}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{string{-}to{-}lex}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"It}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{does}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{not}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{do}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{to}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{leave}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{a}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{live}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{dragon}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktVal{out}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{of}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{your}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{calculations,}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{you}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{live}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{near}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{him"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{magical{-}beasts}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktVal{"dragon"}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{prepositions}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktVal{"near"}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{magical{-}beast{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{member}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{magical{-}beasts}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{preposition{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{member}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{prepositions}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{map}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{s}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{match}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{s}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{magical{-}beast{\hbox{\texttt{?}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textasciigrave}}\RktPn{(}\RktMeta{MAGICAL{-}BEAST}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{,}\RktMeta{s}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{preposition{\hbox{\texttt{?}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textasciigrave}}\RktPn{(}\RktMeta{PREPOSITION}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{,}\RktMeta{s}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{string{\hbox{\texttt{?}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textasciigrave}}\RktPn{(}\RktMeta{TOKEN}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{,}\RktMeta{s}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{string{-}split}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{string{-}to{-}lex}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}((TOKEN "It") (TOKEN "does") (TOKEN "not") (TOKEN "do") (TOKEN "to") (TOKEN "leave") (TOKEN "a") (TOKEN "live") (MAGICAL{-}BEAST "dragon") (TOKEN "out") (TOKEN "of") (TOKEN "your") (TOKEN "calculations,") (TOKEN "if") (TOKEN "you") (TOKEN "live") (PREPOSITION "near") (TOKEN "him"))}\end{SingleColumn}\end{SCodeFlow}

This token list can then be passed to the parser to build the parse tree.

In Racket (and other languages that support string pattern matching with
regular expressions), lexing is easy to do without external library
support. But since \Scribtexttt{lex} (and tools like it) are popular in other
languages, it{'}s worth writing a simple lexer using a \Scribtexttt{lex} library in
Racket.

We{'}ll now define a lexer for a subset of C{'}s grammar. We{'}ll use the lex
tool that is implemented in a Racket package called \Scribtexttt{br{-}parser{-}tools}.

First, we{'}ll define all possible tokens that our lexer can generate from the
source code. We{'}ll call the first few \Scribtexttt{value{-}tokens} since they contain literal
values from the original source code.

\label{t:x28elem_x28chunk_x22x3cvaluex2dtokensx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cvaluex2dtokensx3ex3a1x22x29x29]{\plainlink{$<$value{-}tokens$>$}}} ::=}

\begin{SCodeFlow}\RktPn{(}\RktSym{\badlink{\RktValLink{define{-}tokens}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{value{-}tokens}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{INT}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{DOUBLE}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{CHAR}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{STRING}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{ID}\RktPn{)}\RktPn{)}\end{SCodeFlow}

Then we{'}ll define the tokens that don{'}t need to contain any literal values
from the source code, since the name of the token reflects the original
value of the word in the source code.

\label{t:x28elem_x28chunk_x22x3ckeywordx2dtokensx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3ckeywordx2dtokensx3ex3a1x22x29x29]{\plainlink{$<$keyword{-}tokens$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define{-}empty{-}tokens}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{keyword{-}tokens}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{/}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\Stttextless}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{=}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{+=}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}=}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{return}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktSym{COMMA}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{POUND}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{SEMI}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{LBRACE}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{RBRACE}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{LPAREN}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{RPAREN}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{LSQUARE}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{RSQUARE}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{EOF}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

The full lexer will have the following structure:

\label{t:x28elem_x28chunk_x22x3clexerx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3clexerx3ex3a1x22x29x29]{\plainlink{$<$lexer$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{c{-}lexer}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lexer}}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktPn{(}\RktSym{eof}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{EOF}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\hyperref[t:x28elem_x28chunk_x22x3cskipx2dwhitespacex3ex3a1x22x29x29]{\plainlink{$<$skip{-}whitespace$>$}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\hyperref[t:x28elem_x28chunk_x22x3cmatchx2dkeywordx2dtokensx3ex3a1x22x29x29]{\plainlink{$<$match{-}keyword{-}tokens$>$}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\hyperref[t:x28elem_x28chunk_x22x3csyntaxx2dsymbolsx3ex3a1x22x29x29]{\plainlink{$<$syntax{-}symbols$>$}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\hyperref[t:x28elem_x28chunk_x22x3cintegerx3ex3a1x22x29x29]{\plainlink{$<$integer$>$}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\hyperref[t:x28elem_x28chunk_x22x3cdoublex3ex3a1x22x29x29]{\plainlink{$<$double$>$}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\hyperref[t:x28elem_x28chunk_x22x3cidx3ex3a1x22x29x29]{\plainlink{$<$id$>$}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\hyperref[t:x28elem_x28chunk_x22x3ccharx3ex3a1x22x29x29]{\plainlink{$<$char$>$}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\hyperref[t:x28elem_x28chunk_x22x3cstringx3ex3a1x22x29x29]{\plainlink{$<$string$>$}}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Since whitespace is semantically insignificant in C, we can completely
ignore it. We{'}ll write a rule to skip whitespace by recursively calling
the lexer function itself on the next token in the input.

\label{t:x28elem_x28chunk_x22x3cskipx2dwhitespacex3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cskipx2dwhitespacex3ex3a1x22x29x29]{\plainlink{$<$skip{-}whitespace$>$}}} ::=}

\begin{SCodeFlow}\RktPn{(}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}or}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}tab}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}space}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}newline}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{c{-}lexer}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{input{-}port}}}\RktPn{)}\RktPn{)}\end{SCodeFlow}

The \Scribtexttt{lex} rules are defined by matching a certain string, and returning
the symbol associated with the token. For the rules where the string can
easily be converted into the token of the same name, we{'}ll convert the
string to a symbol with \Scribtexttt{string{-}{\Stttextmore}symbol} and return the token
immediately. The \Scribtexttt{lex} tool automatically creates a variable called
\Scribtexttt{lexeme} to store the value of the current string.

\label{t:x28elem_x28chunk_x22x3cmatchx2dkeywordx2dtokensx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cmatchx2dkeywordx2dtokensx3ex3a1x22x29x29]{\plainlink{$<$match{-}keyword{-}tokens$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}or}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"if"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"else"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"*"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"/"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"+"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"{-}"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"{\Stttextless}"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"{\Stttextmore}"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"="}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"+="}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"{-}="}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"return"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{string{-}{\Stttextmore}symbol}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{lexeme}}}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Now we{'}ll write the rules for matching the other tokens.

\label{t:x28elem_x28chunk_x22x3csyntaxx2dsymbolsx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3csyntaxx2dsymbolsx3ex3a1x22x29x29]{\plainlink{$<$syntax{-}symbols$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktVal{"{\char`\{}"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{LBRACE}\RktPn{)}

\RktPn{(}\RktVal{"{\char`\}}"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{RBRACE}\RktPn{)}

\RktPn{(}\RktVal{"["}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{LSQUARE}\RktPn{)}

\RktPn{(}\RktVal{"]"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{RSQUARE}\RktPn{)}

\RktPn{(}\RktVal{"("}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{LPAREN}\RktPn{)}

\RktPn{(}\RktVal{")"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{RPAREN}\RktPn{)}

\RktPn{(}\RktVal{";"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{SEMI}\RktPn{)}

\RktPn{(}\RktVal{"\#"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{POUND}\RktPn{)}

\RktPn{(}\RktVal{","}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{COMMA}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

To lex numbers, we{'}ll have to write a slightly more sophisticated rule,
since it isn{'}t viable to write a \Scribtexttt{lex} rule to match
every possible number. We{'}ll be using \textit{regular expressions} to do
this. Regular expressions are the simplest type of formal language to
parse, and are cheap to compute.

The \Scribtexttt{{\hbox{\texttt{:}}}+} function lets us parse one or more matches of a sub{-}rule. The
\Scribtexttt{{\hbox{\texttt{:}}}/} function will match any character in the range of ASCII characters
it is passed. In our case, we want to match the ASCII characters that are
between the value {'}0{'} and {'}9{'}, and we{'}ll use the \Scribtexttt{{\hbox{\texttt{:}}}+} function to match
multiple digits.

\label{t:x28elem_x28chunk_x22x3cintegerx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cintegerx3ex3a1x22x29x29]{\plainlink{$<$integer$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}+}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}/}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"0"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"9"}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{token{-}INT}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{string{-}{\Stttextmore}number}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{lexeme}}}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Doubles are just two integers separated by a decimal point, so we{'}ll use
the \Scribtexttt{{\hbox{\texttt{:}}}seq} function to parse a sequence of patterns. Once the first
pattern fails to match, it moves onto the next one until it finishes
parsing.

\label{t:x28elem_x28chunk_x22x3cdoublex3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cdoublex3ex3a1x22x29x29]{\plainlink{$<$double$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}seq}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}+}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}/}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"0"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"9"}\RktPn{)}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}{\hbox{\texttt{.}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}+}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}/}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"0"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"9"}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{token{-}DOUBLE}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{string{-}{\Stttextmore}number}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{lexeme}}}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Often in C, we expect a word for a type, variable, or function name, but
don{'}t know what the name will be (since it is user defined). To parse
these types of \textit{identifiers} we must define a \Scribtexttt{lex} rule to
match an identifier. A valid identifier starts with an ASCII character and
has either characters or numbers in the rest of the name
(underscores and capital letters are valid in C{'}s grammar as well, but
             we{'}ll leave them out for simplicity).

\label{t:x28elem_x28chunk_x22x3cidx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cidx3ex3a1x22x29x29]{\plainlink{$<$id$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}seq}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}/}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"a"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"z"}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}*}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}or}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}/}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"a"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"z"}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}/}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"0"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"9"}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{token{-}ID}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{lexeme}}}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

C characters literals are notated by a quote followed by an ASCII
character and another quote.

\label{t:x28elem_x28chunk_x22x3ccharx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3ccharx3ex3a1x22x29x29]{\plainlink{$<$char$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}seq}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"{\textquotesingle}"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{any{-}char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"{\textquotesingle}"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{token{-}CHAR}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{string{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{lexeme}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

And lastly, strings are denoted by a double quote, followed by zero or
more characters that \textit{aren{'}t} a double quote.

We{'}ll use the \Scribtexttt{{\hbox{\texttt{:}}}*} function to match zero or more characters, and we{'}ll
use the char{-}complement function to match any character that isn{'}t the
double quote.

\label{t:x28elem_x28chunk_x22x3cstringx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cstringx3ex3a1x22x29x29]{\plainlink{$<$string$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}seq}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}"}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{:}}}*}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{char{-}complement}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}"}\RktPn{)}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{token{-}STRING}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{substring}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{lexeme}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\mbox{{-}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{string{-}length}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{lexeme}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{2}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Putting it all together, we get the final module file:

\label{t:x28elem_x28chunk_x22x3cx2ax3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cx2ax3ex3a1x22x29x29]{\plainlink{$<$*$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{require}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{br{-}parser{-}tools/lex}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{prefix{-}in}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{br{-}parser{-}tools/lex{-}sre}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}

\RktPn{(}\RktSym{provide}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{value{-}tokens}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{keyword{-}tokens}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{c{-}lexer}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}

\hyperref[t:x28elem_x28chunk_x22x3cvaluex2dtokensx3ex3a1x22x29x29]{\plainlink{$<$value{-}tokens$>$}}

\hyperref[t:x28elem_x28chunk_x22x3ckeywordx2dtokensx3ex3a1x22x29x29]{\plainlink{$<$keyword{-}tokens$>$}}

\hyperref[t:x28elem_x28chunk_x22x3clexerx3ex3a1x22x29x29]{\plainlink{$<$lexer$>$}}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Our lexer can be used in the following manner
(though it generally isn{'}t used on its own {-} we{'}ll add the parser next):

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{test{-}input}} \\
\hbox{\RktMeta{}\RktPn{(}\RktMeta{open{-}input{-}string}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"int}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{main}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\char`\{}}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktVal{printf({\char`\\}"hello}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{world{\hbox{\texttt{!}}}{\char`\\}n{\char`\\}");}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktVal{return}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{0;}} \\
\hbox{\RktVal{{\char`\}}"}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktCmt{;}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{now}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{we{\textquotesingle}ll}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{lex}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{the}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{whole}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{string}\RktMeta{}} \\
\hbox{\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{lex{-}loop}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktCmt{;}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{lex}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{until}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{we}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{get}\mbox{\hphantom{\Scribtexttt{x}}}\RktCmt{EOF}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{tok}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{c{-}lexer}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{test{-}input}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tok}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{EOF}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{append}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tok}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lex{-}loop}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(list (token {\textquotesingle}ID "int") (token {\textquotesingle}ID "main") {\textquotesingle}LBRACE (token {\textquotesingle}ID "printf") {\textquotesingle}LPAREN (token {\textquotesingle}STRING "hello world{\hbox{\texttt{!}}}") {\textquotesingle}RPAREN {\textquotesingle}SEMI {\textquotesingle}return (token {\textquotesingle}INT 0) {\textquotesingle}SEMI {\textquotesingle}RBRACE)}\end{SingleColumn}\end{SCodeFlow}

Racket uses a macro to generate the lexer code at compile time. In the
original \Scribtexttt{lex} (designed for C), a developer embeds the lexer code in
a specially annotated block in a C program. Then, they call the \Scribtexttt{lex}
utility on the file to generate the full C source for the lexer.

While lexers and parsers may seem similar, the key difference between the
two is that parsers are more sophisticated than lexers. A lexer simply
matches and splits the input string then the parser builds a tree from the
tokens with semantic structure. A lexer takes flat data as an input
(a string) and returns flat data (an array of tokens), whereas a parser
takes an array of tokens and constructs a tree.

\Ssubsection{A \Scribtexttt{yacc} parser}{A \Scribtexttt{yacc} parser}\label{t:x28part_x22Ax5fyaccx5fparserx22x29}

\Scribtexttt{yacc} is a tool for generating LALR\NoteBox{\NoteContent{Look ahead, left{-}to{-}right,
rightmost deriviation}} parsers.  The original tool was written in C,
and generated C source code, but we will be using a port of \Scribtexttt{yacc} implemented
in the racket \Scribtexttt{br{-}parser{-}tools} library.

With classic \Scribtexttt{yacc} implementations, the generated code
is convoluted and difficult to understand (as most generated code is).
Since we{'}re once using a Racket implementation, the parser generation step will be
hidden in a macro, so our parser source is more readable.

Let{'}s build a parser to continue parsing our C grammar example from before with
\Scribtexttt{yacc}. We{'}ll assume a lexer with tokens like the ones we defined in the \Scribtexttt{lex}
example.

\Scribtexttt{yacc} grammars are constructed out of "rules." Unlike regular expression
rules, \Scribtexttt{yacc} rules can reference themselves recursively. This
allows for more powerful parsing rules.

Let{'}s start with adding a simple rule to our parser called \Scribtexttt{number} that
parses numeric values.

First we{'}ll include the necessary libraries

\label{t:x28elem_x28chunk_x22x3cincludesx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cincludesx3ex3a1x22x29x29]{\plainlink{$<$includes$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{require}

\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{br{-}parser{-}tools/yacc}

\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{br{-}parser{-}tools/lex}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{prefix{-}in}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{br{-}parser{-}tools/lex{-}sre}\RktPn{)}\RktPn{)}

\RktPn{(}\RktSym{require}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"c{-}lexer{\hbox{\texttt{.}}}scrbl"}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Then, we{'}ll write the \Scribtexttt{numbers} rule.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{num{-}parser}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{parser}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{error}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{tok{-}ok{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tok{-}name}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tok{-}value}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{error}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"parsing}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{failed,}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{unexpected}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tok{-}name}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tok{-}value}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{start}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{number}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{tokens}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{keyword{-}tokens}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{value{-}tokens}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{end}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{EOF}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{grammar}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{number}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{INT}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$1}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{DOUBLE}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$1}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktErr{52 shift/reduce conflicts
}\end{SingleColumn}\end{SCodeFlow}

This is a fully functioning parser! It doesn{'}t parse much, and it only
constructs a tree of one node, but it is capable of parsing valid "programs."

An example to demonstrate what it can do:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{test{-}input}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{open{-}input{-}string}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"2"}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{num{-}parser}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{c{-}lexer}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{test{-}input}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{2}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{test{-}input}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{open{-}input{-}string}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"a}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{string}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{of}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{text}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{to}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{make}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{it}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{fail"}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{num{-}parser}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{c{-}lexer}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{test{-}input}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktErr{parsing failed, unexpected  ID "a"
  context...:
   /home/nc/.racket/6.12/pkgs/br{-}parser{-}tools{-}lib/br{-}parser{-}tools/yacc.rkt:353:14: parsing{-}loop
   /usr/share/racket/collects/racket/private/more{-}scheme.rkt:148:2: call{-}with{-}break{-}parameterization
   .../more{-}scheme.rkt:261:28
   /usr/share/racket/pkgs/sandbox{-}lib/racket/sandbox.rkt:861:5: loop
}\end{SingleColumn}\end{SCodeFlow}

A \Scribtexttt{number} can be an \Scribtexttt{INT} token or a \Scribtexttt{DOUBLE} token. Since we have
both \Scribtexttt{INT} and \Scribtexttt{DOUBLE} listed as numbers, the rule will match either token
when it appears in the token stream.

The variables with the {'}\${'} prefix (\Scribtexttt{\$1} in this case) reference the i\textsuper{th}
variable in the match list. For instance, \Scribtexttt{((A B C) (list \$1 \$3))}, would
return a list with the \Scribtexttt{A} and \Scribtexttt{C} tokens (i.e. the first and third).

We{'}ll use these simple patterns to build the rest of our parser.

For a full{-}fledged parser we have to define a few things first. The overall
structure is shown below:

\label{t:x28elem_x28chunk_x22x3cx2ax3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cx2ax3ex3a1x22x29x29]{\plainlink{$<$*$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\hyperref[t:x28elem_x28chunk_x22x3cincludesx3ex3a1x22x29x29]{\plainlink{$<$includes$>$}}

\RktPn{(}\RktSym{provide}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{c{-}parser}\RktPn{)}

\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{c{-}parser}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser}}}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{tokens}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{keyword{-}tokens}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{value{-}tokens}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{error}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{tok{-}ok{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{tok{-}name}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{tok{-}value}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{error}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"parsing failed, unexpected"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{tok{-}name}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{tok{-}value}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{start}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{func{-}def}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{end}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{EOF}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\hyperref[t:x28elem_x28chunk_x22x3cprecsx3ex3a1x22x29x29]{\plainlink{$<$precs$>$}}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{grammar}

\mbox{\hphantom{\Scribtexttt{xxx}}}\hyperref[t:x28elem_x28chunk_x22x3cliteralx3ex3a1x22x29x29]{\plainlink{$<$literal$>$}}

\mbox{\hphantom{\Scribtexttt{xxx}}}\hyperref[t:x28elem_x28chunk_x22x3cexprx2dlistx3ex3a1x22x29x29]{\plainlink{$<$expr{-}list$>$}}

\mbox{\hphantom{\Scribtexttt{xxx}}}\hyperref[t:x28elem_x28chunk_x22x3cexprx3ex3a1x22x29x29]{\plainlink{$<$expr$>$}}

\mbox{\hphantom{\Scribtexttt{xxx}}}\hyperref[t:x28elem_x28chunk_x22x3cvarx2ddeclx3ex3a1x22x29x29]{\plainlink{$<$var{-}decl$>$}}

\mbox{\hphantom{\Scribtexttt{xxx}}}\hyperref[t:x28elem_x28chunk_x22x3cfuncx2ddefx3ex3a1x22x29x29]{\plainlink{$<$func{-}def$>$}}

\mbox{\hphantom{\Scribtexttt{xxx}}}\hyperref[t:x28elem_x28chunk_x22x3cargx2dlistx3ex3a1x22x29x29]{\plainlink{$<$arg{-}list$>$}}

\mbox{\hphantom{\Scribtexttt{xxx}}}\hyperref[t:x28elem_x28chunk_x22x3cstmtx3ex3a1x22x29x29]{\plainlink{$<$stmt$>$}}

\mbox{\hphantom{\Scribtexttt{xxx}}}\hyperref[t:x28elem_x28chunk_x22x3cmaybex2delsex3ex3a1x22x29x29]{\plainlink{$<$maybe{-}else$>$}}

\mbox{\hphantom{\Scribtexttt{xxx}}}\hyperref[t:x28elem_x28chunk_x22x3cstmtx2dlistx3ex3a1x22x29x29]{\plainlink{$<$stmt{-}list$>$}}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

To avoid ambiguities when parsing infix operators, we{'}ll define operator precedence next.

\label{t:x28elem_x28chunk_x22x3cprecsx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cprecsx3ex3a1x22x29x29]{\plainlink{$<$precs$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{precs}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{right}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{=}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{left}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{+}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{left}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{/}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Now we can write the individual grammar rules. String, character, numeric,
and other hardcoded values in a program are often called "literals." Since
they{'}re easy to parse, we{'}ll start with them.

\label{t:x28elem_x28chunk_x22x3cliteralx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cliteralx3ex3a1x22x29x29]{\plainlink{$<$literal$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{literal}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{INT}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{DOUBLE}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{CHAR}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{STRING}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Since the token already contains the literal value, we don{'}t need to do
any manipulation and can return the token directly with \Scribtexttt{\$1}.

Not every language differentiates between expressions and statements
as C does. Scheme for instance has no grammatical structure for
statements. Since C has statments, our parser must differentiate between
expressions and statements, so if a program attempts to use a statement
in the context of an expression, the parser will fail.

In our parser, we{'}ll handle variable declaration statements, return
statements, and if statements. We will define these rules later.

Now we{'}ll write a rule to parse expressions.

\label{t:x28elem_x28chunk_x22x3cexprx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cexprx3ex3a1x22x29x29]{\plainlink{$<$expr$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{expr}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{ID}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{=}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{assign}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{literal}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{ID}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\hyperref[t:x28elem_x28chunk_x22x3cbinopsx3ex3a1x22x29x29]{\plainlink{$<$binops$>$}}

\mbox{\hphantom{\Scribtexttt{x}}}\hyperref[t:x28elem_x28chunk_x22x3cfunctionx2dcallx3ex3a1x22x29x29]{\plainlink{$<$function{-}call$>$}}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

The assignment rule is slightly more sophisticated than the rules shown
before. First, it{'}s recursive which allows us to write more powerful
rules.  Second, when we construct the returned results, we do a small
transformation to make it a list where the first element is the symbol
"assign." We tag the first element in the list to make differentiation between
different node types easier.

Next we define our infix operations (once again using simple tagged lists to make the
nodes differentiable).

\label{t:x28elem_x28chunk_x22x3cbinopsx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cbinopsx3ex3a1x22x29x29]{\plainlink{$<$binops$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktPn{(}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\RktPn{(}\RktPn{(}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{\mbox{{-}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\RktPn{(}\RktPn{(}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\RktPn{(}\RktPn{(}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{/}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{/}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\RktPn{(}\RktPn{(}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\Stttextless}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{{\Stttextless}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\RktPn{(}\RktPn{(}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\RktPn{(}\RktPn{(}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{+=}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{+=}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\RktPn{(}\RktPn{(}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}=}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{\mbox{{-}=}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

These grammar rules employ left{-}recursion, since it is allowed in \Scribtexttt{yacc}.
This is because \Scribtexttt{yacc} is a bottom{-}up parser, so left{-}recursion doesn{'}t
need to be eliminated as it does in a top{-}down parser.

To finish our expression rules, we add a rule for parsing function calls.

\label{t:x28elem_x28chunk_x22x3cfunctionx2dcallx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cfunctionx2dcallx3ex3a1x22x29x29]{\plainlink{$<$function{-}call$>$}}} ::=}

\begin{SCodeFlow}\RktPn{(}\RktPn{(}\RktSym{ID}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{LPAREN}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr{-}list}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{RPAREN}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}\end{SCodeFlow}

Since we don{'}t know how many expressions will show up in an expression
list (for a function call, for instance), we must parse until the end of the
list.

\label{t:x28elem_x28chunk_x22x3cexprx2dlistx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cexprx2dlistx3ex3a1x22x29x29]{\plainlink{$<$expr{-}list$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{expr{-}list}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{COMMA}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr{-}list}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{expr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

By matching an expression \textit{and} a comma, followed by a recursive
match of the expression list again, we can determine when to stop. When
the token after the next expression is \textit{not} a comma, the parser
terminates with one of the last two rules.

Now we must define rules for to parse statements. Note that an expression
followed by a semi{-}colon is also a statement.

\label{t:x28elem_x28chunk_x22x3cstmtx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cstmtx3ex3a1x22x29x29]{\plainlink{$<$stmt$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{stmt}

\mbox{\hphantom{\Scribtexttt{x}}}\hyperref[t:x28elem_x28chunk_x22x3cifx2dstmtx3ex3a1x22x29x29]{\plainlink{$<$if{-}stmt$>$}}

\mbox{\hphantom{\Scribtexttt{x}}}\hyperref[t:x28elem_x28chunk_x22x3creturnx2dstmtx3ex3a1x22x29x29]{\plainlink{$<$return{-}stmt$>$}}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{var{-}decl}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{SEMI}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{SEMI}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Variable declaration simply parses two identifiers. The first is the type
of the variable and the second is its name. We{'}ll use this \Scribtexttt{var{-}decl}
later on for parameter definitions in our \Scribtexttt{func{-}def} rule, so it has
its own rule.

\label{t:x28elem_x28chunk_x22x3cvarx2ddeclx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cvarx2ddeclx3ex3a1x22x29x29]{\plainlink{$<$var{-}decl$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{var{-}decl}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{ID}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{ID}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{decl}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$2}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Return statements are straightforward as well {-} they{'}re simply the return
keyword followed by an expression and a semicolon to delimit the end of the statement.

\label{t:x28elem_x28chunk_x22x3creturnx2dstmtx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3creturnx2dstmtx3ex3a1x22x29x29]{\plainlink{$<$return{-}stmt$>$}}} ::=}

\begin{SCodeFlow}\RktPn{(}\RktPn{(}\RktSym{return}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{SEMI}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{return}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$2}\RktPn{)}\RktPn{)}\end{SCodeFlow}

\Scribtexttt{if} statements are composed of many tokens, and have an optional else statement.

\label{t:x28elem_x28chunk_x22x3cifx2dstmtx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cifx2dstmtx3ex3a1x22x29x29]{\plainlink{$<$if{-}stmt$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{LPAREN}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{RPAREN}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{LBRACE}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{stmt{-}list}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{RBRACE}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{maybe{-}else}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{append}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$6}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$8}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

We{'}ll include a rule called \Scribtexttt{maybe{-}else} which will return an empty list if the
else statement doesn{'}t exist.

\label{t:x28elem_x28chunk_x22x3cmaybex2delsex3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cmaybex2delsex3ex3a1x22x29x29]{\plainlink{$<$maybe{-}else$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{maybe{-}else}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{LBRACE}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{stmt{-}list}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{RBRACE}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

When \Scribtexttt{maybe{-}else} rule returns an empty list the \Scribtexttt{if} parser
rule will have nothing to \Scribtexttt{append}. When there is, an else statement, the
\Scribtexttt{}\Scribtexttt{{'}}\Scribtexttt{else} will be tagged on the end, along with the block of statements
(from the \Scribtexttt{stmt{-}list} rule).

\label{t:x28elem_x28chunk_x22x3cstmtx2dlistx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cstmtx2dlistx3ex3a1x22x29x29]{\plainlink{$<$stmt{-}list$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{stmt{-}list}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{stmt}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{stmt{-}list}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$2}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

The last significant rule is the top{-}level rule that utilizes all the
above rules to construct function definitions. To parse a full{-}scale
C program, our starting rule would need to be a list of function
definitions, we{'}ll keep it simple for now by just parsing one.

\label{t:x28elem_x28chunk_x22x3cfuncx2ddefx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cfuncx2ddefx3ex3a1x22x29x29]{\plainlink{$<$func{-}def$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{func{-}def}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{ID}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{ID}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{LPAREN}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{arg{-}list}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{RPAREN}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{LBRACE}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{stmt{-}list}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{RBRACE}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{func{-}def}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$2}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$4}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$7}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

The final rule is the argument list helper which expects a list of \Scribtexttt{var{-}decl}s that
we defined earlier.

\label{t:x28elem_x28chunk_x22x3cargx2dlistx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cargx2dlistx3ex3a1x22x29x29]{\plainlink{$<$arg{-}list$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{arg{-}list}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{var{-}decl}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{COMMA}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{arg{-}list}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$3}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{var{-}decl}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$1}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{list}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Now we can parse C{-}ish looking programs! For example,

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{with{-}input{-}from{-}string}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktVal{"int}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{main()}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\char`\{}}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktVal{int}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{x;}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktVal{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{=}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{rand(0,}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{3);}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktVal{int}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{i;}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktVal{i}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{=}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{2;}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktVal{if(i}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\Stttextless}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{x)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\char`\{}}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktVal{printf({\char`\\}"my}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{number}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{is}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\%d{\char`\\}",}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{x);}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktVal{{\char`\}}}} \\
\hbox{\RktVal{{\char`\}}"}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{c{-}parser}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{c{-}lexer}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{current{-}input{-}port}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(func{-}def "int" "main" () ((decl "int" "x") (assign "x" ("rand" 0 3)) (decl "int" "i") (assign "i" 2) (if ({\Stttextless} "i" "x") (("printf" "my number is \%" "x")))))}\end{SingleColumn}\end{SCodeFlow}

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{with{-}input{-}from{-}string}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktVal{"int}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{add(int}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{a,}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{int}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{b)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\char`\{}}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktVal{return}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{a}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{b;}} \\
\hbox{\RktVal{{\char`\}}"}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{c{-}parser}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{c{-}lexer}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{current{-}input{-}port}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(func{-}def "int" "add" ((decl "int" "a") (decl "int" "b")) ((return (+ "a" "b"))))}\end{SingleColumn}\end{SCodeFlow}

\Ssubsection{A parser combinator }{A parser combinator }\label{t:x28part_x22Ax5fparserx5fcombinatorx5fx22x29}

Since \Scribtexttt{yacc} and \Scribtexttt{lex} are specialized domain specific languages with
their own grammars and syntaxes, they stand out in source since they don{'}t
follow the outer language{'}s semantics. For Racket, this isn{'}t as much of
an issue since the parser DSL looks like Racket code. However, with the
original \Scribtexttt{lex} and \Scribtexttt{yacc} implementations for C, the \Scribtexttt{lex} and
\Scribtexttt{yacc} code was separated out from the rest of the source, and the
tools would generate temporary C files that weren{'}t easy to hand{-}edited.

When so much code is generated, its difficult to control what gets
generated and how its written. Often languages that original have a parser
implemented in \Scribtexttt{yacc} eventually deprecate the \Scribtexttt{yacc} parser for one
that is hand written to address these issues.

\textit{Parser combinators} address this issue without losing the
declarative nature of a DSL. Parser combinators are parser libraries that
are used to construct parsers using functional composition of
higher{-}order functions. It{'}s a natural way of thinking for functional
programmers. The resulting code is terse, provides lower{-}level control
than a DSL, and is easy to maintain.

Parsec is one of the first real{-}world parser combinators [Leijen,,
, 2001]. It is written in Haskell, but has inspired implementations in many
other languages including OCaml and Racket. We{'}ll use the Racket
implementation (called Parsack) for our parser combinator.

A parser function consumes input from some stream, and returns a result if
parser rule successfully parsed anything. For instance, a parser function
could match the letter "a."

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{require}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{parsack}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{char}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\}a}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"a"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok \#{\char`\\}a))}\end{SingleColumn}\end{SCodeFlow}

There are more general parser functions for matching any character or
digit. We can also match whole strings.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$letter}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"a"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok \#{\char`\\}a))}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$digit}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"3"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok \#{\char`\\}3))}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$digit}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"a"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktErr{parse ERROR: at 1:1:1
unexpected: "a"
  expected: "digit"
  context...:
   /home/nc/.racket/6.12/pkgs/parsack/parsack/parsack.rkt:464:0: parse53
   [repeats 1 more time]
   /usr/share/racket/collects/racket/private/more{-}scheme.rkt:148:2: call{-}with{-}break{-}parameterization
   .../more{-}scheme.rkt:261:28
   /usr/share/racket/pkgs/sandbox{-}lib/racket/sandbox.rkt:861:5: loop
}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{string}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"match}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{this{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"match}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{this{\hbox{\texttt{!}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{2}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{3"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok {\textquotesingle}(\#{\char`\\}m \#{\char`\\}a \#{\char`\\}t \#{\char`\\}c \#{\char`\\}h \#{\char`\\}space \#{\char`\\}t \#{\char`\\}h \#{\char`\\}i \#{\char`\\}s \#{\char`\\}{\hbox{\texttt{!}}})))}\end{SingleColumn}\end{SCodeFlow}

Building a parser with only these few simple functions would get tedious
quickly. If we can attempt to match multiple characters with regular
expressions, we should be able to do the same with a parser.

This is where combinators come in. Combinators are higher{-}order functions
that take other functions as arguments and apply them together to reuse
compose functionality [\hyperref[t:x28cite_x22Trompx22x29]{Tromp}].

A basic combinator is \Scribtexttt{many}, which parses using whatever parser it is
passed until it fails.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{many}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$letter}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"abcde123"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok {\textquotesingle}(\#{\char`\\}a \#{\char`\\}b \#{\char`\\}c \#{\char`\\}d \#{\char`\\}e)))}\end{SingleColumn}\end{SCodeFlow}

We can also use conditional combinators to try another parser if the first
one fails.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{many}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{\Stttextless}or{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$letter}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$digit}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"abcde123{-}{-}{-}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok {\textquotesingle}(\#{\char`\\}a \#{\char`\\}b \#{\char`\\}c \#{\char`\\}d \#{\char`\\}e \#{\char`\\}1 \#{\char`\\}2 \#{\char`\\}3)))}\end{SingleColumn}\end{SCodeFlow}

Sequences of parsers are combined together with the bind function (denoted
\Scribtexttt{{\Stttextmore}{\Stttextmore}=}). The bind function is a higher{-}order function that takes
a parser and a transformation function function. The transformation
function is expected to have the type signature \Scribtexttt{parse{-}result {-}{\Stttextmore}
parser}. The bind function calls the transform function, and executes the
returned parser, returning the final result. So the full type signature
for \Scribtexttt{{\Stttextmore}{\Stttextmore}=} is:

\Scribtexttt{{\Stttextmore}{\Stttextmore}= {\hbox{\texttt{:}}} parser {-}{\Stttextmore} (result {-}{\Stttextmore} parser) {-}{\Stttextmore} result}

Essentially, the bind function is used to construct a pipeline of
transformations that track state so you don{'}t lose the result of the
previous parser.

So if we want to parse an excited word, we could parse many letters followed by
an exclamation point.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{\Stttextmore}{\Stttextmore}=}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{many}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$letter}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{previous{-}letters}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{char}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\}{\hbox{\texttt{!}}}}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktVal{"woot{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok \#{\char`\\}{\hbox{\texttt{!}}}))}\end{SingleColumn}\end{SCodeFlow}

However, since \Scribtexttt{previous{-}result} isn{'}t used, \Scribtexttt{{\Stttextmore}{\Stttextmore}=} only returns the
secound parse result. We need to combine the results and return it. In
the context of parser combinators the \Scribtexttt{return} function doens{'}t have
the same meaning as the return statement in most languages. It
doesn{'}t terminate execution and return the result immediately {-} instead it
simply packages up whatever value was passed to it as a parse result and
passes returns it.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{return}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"i}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{don{\textquotesingle}t}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{care}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{about}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{what}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{needs}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{to}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{be}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{parsed{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"plz}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{me"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Empty (Ok "i don{\textquotesingle}t care about what needs to be parsed{\hbox{\texttt{!}}}"))}\end{SingleColumn}\end{SCodeFlow}

Since it always succeeds, it can be used with conditions to return
a default result.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{\Stttextless}or{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$digit}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{return}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"oops}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{no}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{digits"}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"no}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{numbers}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{here,}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{dood"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Empty (Ok "oops {-} no digits"))}\end{SingleColumn}\end{SCodeFlow}

So in our case of trying to combine the previous results, we want to return the
combined result of two parsers

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{\Stttextmore}{\Stttextmore}=}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{many}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$letter}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{previous{-}letters}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{{\Stttextmore}{\Stttextmore}=}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{char}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\}{\hbox{\texttt{!}}}}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{exclamation{-}point}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{return}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{append}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{previous{-}letters}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{exclamation{-}point}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktVal{"woot{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok {\textquotesingle}(\#{\char`\\}w \#{\char`\\}o \#{\char`\\}o \#{\char`\\}t \#{\char`\\}{\hbox{\texttt{!}}})))}\end{SingleColumn}\end{SCodeFlow}

Using the simple concept of parse results and function composition, we can
then build the rules we need for our parser. Before we start parsing,
there are a few more utility functions that will be useful.

\begin{itemize}\atItemizeStart

\item \Scribtexttt{{\Stttextmore}{\Stttextmore}} (bind, ignoring returned result)


\noindent \begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{\Stttextmore}{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{string}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"don{\textquotesingle}t}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{care"}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$digit}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktVal{"don{\textquotesingle}t}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{care123123"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok {\textquotesingle}(\#{\char`\\}1 \#{\char`\\}2 \#{\char`\\}3 \#{\char`\\}1 \#{\char`\\}2 \#{\char`\\}3)))}\end{SingleColumn}\end{SCodeFlow}

\noindent When we want to ensure a keyword appears, but don{'}t care
        about returning the result in the parse tree, this
        function is very useful.

\item \Scribtexttt{parser{-}seq} and \Scribtexttt{parser{-}one}
(parse a sequence of parsers, combining specified
       results)


\noindent \begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{parser{-}seq}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$letter}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$digit}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{char}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\}{\hbox{\texttt{!}}}}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktVal{"awesom3{\hbox{\texttt{!}}}{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok {\textquotesingle}((\#{\char`\\}a \#{\char`\\}w \#{\char`\\}e \#{\char`\\}s \#{\char`\\}o \#{\char`\\}m) (\#{\char`\\}3) (\#{\char`\\}{\hbox{\texttt{!}}} \#{\char`\\}{\hbox{\texttt{!}}}))))}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{parser{-}seq}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{$\sim$}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$letter}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$digit}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{char}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\}{\hbox{\texttt{!}}}}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktVal{"awesom3{\hbox{\texttt{!}}}{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok {\textquotesingle}((\#{\char`\\}3) (\#{\char`\\}{\hbox{\texttt{!}}} \#{\char`\\}{\hbox{\texttt{!}}}))))}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{parser{-}one}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$letter}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{$\sim${\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$digit}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{char}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\}{\hbox{\texttt{!}}}}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktVal{"awesom3{\hbox{\texttt{!}}}{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok {\textquotesingle}(\#{\char`\\}3)))}\end{SingleColumn}\end{SCodeFlow}

\noindent Both these functions just do the bind calls internally and
hide the lambdas to make the code easier to read.
\Scribtexttt{parser{-}seq} will combine the parse results into a
list, ignoring any parsers with a \Scribtexttt{$\sim$} in front of it,
and \Scribtexttt{parser{-}one} is the exact same, but it only
returns one result (whichever parser is prefixed with \Scribtexttt{$\sim${\Stttextmore}}).

\item \Scribtexttt{sepBy} and \Scribtexttt{endBy} (parse seperators)


\noindent \begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{sepBy}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$letter}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$spaces}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktVal{"such}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{words}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{many}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{wow"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok {\textquotesingle}((\#{\char`\\}s \#{\char`\\}u \#{\char`\\}c \#{\char`\\}h) (\#{\char`\\}w \#{\char`\\}o \#{\char`\\}r \#{\char`\\}d \#{\char`\\}s) (\#{\char`\\}m \#{\char`\\}a \#{\char`\\}n \#{\char`\\}y) (\#{\char`\\}w \#{\char`\\}o \#{\char`\\}w))))}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{endBy}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{many1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{\$letter}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{char}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\},}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktVal{"expect,a,comma,bru,"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{(Consumed (Ok {\textquotesingle}((\#{\char`\\}e \#{\char`\\}x \#{\char`\\}p \#{\char`\\}e \#{\char`\\}c \#{\char`\\}t) (\#{\char`\\}a) (\#{\char`\\}c \#{\char`\\}o \#{\char`\\}m \#{\char`\\}m \#{\char`\\}a) (\#{\char`\\}b \#{\char`\\}r \#{\char`\\}u))))}\end{SingleColumn}\end{SCodeFlow}

These functions are fairly self{-}explanitory {-} they
parse the first parser until they reach the seperator
(the second argument) and repeat until the end.
\Scribtexttt{sepBy} expects no seperator at the end and \Scribtexttt{endBy}
expects the separator.\end{itemize}

There are many more combinators that can be found in the parsack
documentation [\hyperref[t:x28cite_x22Parsack_docsx22x29]{Parsack docs}], but this list contains the main
combinators we use for the parser we build.

Again, we{'}re going to parse a C{-}ish language, since it has enough non{-}trivial
syntax rules to be interesting.

\label{t:x28elem_x28chunk_x22x3cincludesx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cincludesx3ex3a1x22x29x29]{\plainlink{$<$includes$>$}}} ::=}

\begin{SCodeFlow}\RktPn{(}\RktSym{\badlink{\RktValLink{require}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{parsack}\RktPn{)}\end{SCodeFlow}

A parse "rule" could be defined as a function in a parser combinator. For
instance, a number parser would be written,

\label{t:x28elem_x28chunk_x22x3cnumberx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cnumberx3ex3a1x22x29x29]{\plainlink{$<$number$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$number}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextless}or{\Stttextmore}}}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{try}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}seq}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{many}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$digit}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}{\hbox{\texttt{.}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{many}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$digit}}}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{r}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{string{-}{\Stttextmore}number}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{list{-}{\Stttextmore}string}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{append}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{car}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{r}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{list}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{cadr}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{r}\RktPn{)}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{caddr}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{r}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{many}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$digit}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{r}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{string{-}{\Stttextmore}number}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{list{-}{\Stttextmore}string}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{r}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

\noindent \NoteBox{\NoteContent{In this case, the angle bracketed function \Scribtexttt{{\Stttextless}or{\Stttextmore}} is the actual function
name (not a literate programming reference to a different block).}}

Parser combinators look like regular function calls in language. Besides
a few odd function names, they{'}re fairly self{-}explanatory. The rule above
parses either a series of digits followed by a dot followed by a series of
digits (for doubles) or a series of digits (for integers)

Likewise, parsing strings and characters is straightforward.

\label{t:x28elem_x28chunk_x22x3cstringx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cstringx3ex3a1x22x29x29]{\plainlink{$<$string$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$string}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{manyUntil}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$anyChar}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}"}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{p}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{list{-}{\Stttextmore}string}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{p}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

\label{t:x28elem_x28chunk_x22x3ccharx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3ccharx3ex3a1x22x29x29]{\plainlink{$<$char$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$char}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}one}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}{\textquotesingle}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktPn{(}\RktSym{$\sim${\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$anyChar}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}{\textquotesingle}}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

The \Scribtexttt{\$identifier} rule is built into Parsack and is convenient
for parsing variable and function identifiers. However, it returns an
array of characters, when it would be nicer to return a string. We{'}ll
write a function that does this conversion for us.

\label{t:x28elem_x28chunk_x22x3csidentifierx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3csidentifierx3ex3a1x22x29x29]{\plainlink{$<$sidentifier$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$sidentifier}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$identifier}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{v}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{list{-}{\Stttextmore}string}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{v}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Now, a rule for parsing variable assignment.

\label{t:x28elem_x28chunk_x22x3cvarx2dassignx2duglyx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cvarx2dassignx2duglyx3ex3a1x22x29x29]{\plainlink{$<$var{-}assign{-}ugly$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$var{-}assign{-}ugly}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}seq}}}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktSym{\$sidentifier}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{$\sim$}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}=}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{$\sim$}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktSym{\$expr}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{j}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{j}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

It{'}s going to get annoying annoying having to parse out the \Scribtexttt{\$spaces}
after every word in the expression. We{'}ll write a macro to insert optional
spaces between every parser for us.

\label{t:x28elem_x28chunk_x22x3cinterspersex2dspacesx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cinterspersex2dspacesx3ex3a1x22x29x29]{\plainlink{$<$intersperse{-}spaces$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{require}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{for{-}syntax}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{racket/match}\RktPn{)}\RktPn{)}

\RktPn{(}\RktSym{\badlink{\RktValLink{require}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{for{-}syntax}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{except{-}in}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{racket}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{string}}}\RktPn{)}\RktPn{)}\RktPn{)}

\RktPn{(}\RktSym{\badlink{\RktValLink{define{-}syntax}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{intersperse{-}spaces}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{stx}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{letrec}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{intersperse}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{match{-}lambda**}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{{\char`\_}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktPn{(}\RktSym{\badlink{\RktValLink{list}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{{\char`\_}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktRdr{,}\RktSym{x}\RktVal{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktPn{(}\RktSym{\badlink{\RktValLink{cons}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{a}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{b}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{sep}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{cons}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{a}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{cons}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{sep}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{intersperse}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{b}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{sep}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{let}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{l}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{syntax{-}{\Stttextmore}datum}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{stx}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{match}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{l}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{\badlink{\RktValLink{list}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{{\char`\_}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{f}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{args}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{datum{-}{\Stttextmore}syntax}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{stx}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{cons}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{f}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{intersperse}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{args}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{$\sim$}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\$spaces}\RktVal{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{else}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{error}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{intersperse{-}spaces}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktVal{"expecting function and arguments to intersperse"}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Now we can use the \Scribtexttt{intersperse{-}spaces} macro to rewrite the variable
assignment rule.

\label{t:x28elem_x28chunk_x22x3cvarx2dassignx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cvarx2dassignx3ex3a1x22x29x29]{\plainlink{$<$var{-}assign$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{intersperse{-}spaces}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{\badlink{\RktValLink{parser{-}seq}}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{\$sidentifier}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}=}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{\$expr}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{j}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{append}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{list}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{=}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{car}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{j}\RktPn{)}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{caddr}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{j}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Function calls are simply:

\label{t:x28elem_x28chunk_x22x3cfuncallx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cfuncallx3ex3a1x22x29x29]{\plainlink{$<$funcall$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{intersperse{-}spaces}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktSym{\badlink{\RktValLink{parser{-}seq}}}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktSym{\$sidentifier}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{between}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}(}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\})}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{sepBy}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\},}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Infix operators (also known as binary operators) are trickier to implement
in a parser combinator than in \Scribtexttt{yacc}. The following rule will not
work.

\label{t:x28elem_x28chunk_x22x3cbinopx2dbadx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cbinopx2dbadx3ex3a1x22x29x29]{\plainlink{$<$binop{-}bad$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}compose}}}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{lhs}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\Stttextless}{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktSym{\badlink{\RktValLink{\$spaces}}}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{op}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\Stttextless}{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{oneOf}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"+{-}/*{\Stttextless}{\Stttextmore}"}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktSym{\badlink{\RktValLink{\$spaces}}}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{rhs}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\Stttextless}{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{list}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{op}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{lhs}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{rhs}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

If we try to do this, we will run into a problem. The \Scribtexttt{lhs} references
an \Scribtexttt{\$expr}, which is the rule we{'}re currently defining. We{'}re allowed
to recursively reference the current rule later in the rule (when we use
the \Scribtexttt{parser{-}seq} or \Scribtexttt{parser{-}compose} macros, since they expand to
lambda functions which delay the evaluation of reference \Scribtexttt{\$expr}).
However, we cannot reference it as the first term in the rule. Recursively
referencing the current rule as the first term isn{'}t allowed since it is
a form of left{-}recursion. To eliminate left{-}recursion, we{'}ll use the
algorithm from the [\hyperref[t:x28cite_x22Dragon_bookx22x29]{Dragon book}] (Section 4.3.3.).

\RktMeta{for}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{each}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{production}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{in}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{the}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{grammar{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{the}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{production}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{has}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{the}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{form}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{A}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{-}{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{AX}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\Stttextbar}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{Y{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{(where}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{X,}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{Y}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{are}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{any}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{number}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{of}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{terminals}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{or}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{nonterminals}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{that}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{do}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{not}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{begin}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{with}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{A)}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{replace}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{the}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{production}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{with}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{the}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{following{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{A}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{-}{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{YA{\textquotesingle}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{A{\textquotesingle}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{-}{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{XAA{\textquotesingle}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\Stttextbar}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{$\varepsilon$}

Without left recursion, our infix operator rule looks like:

\label{t:x28elem_x28chunk_x22x3cbinopx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cbinopx3ex3a1x22x29x29]{\plainlink{$<$binop$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$binop}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}compose}}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{op}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\Stttextless}{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{oneOf}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"+/*{\Stttextless}{\Stttextmore}"}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{\badlink{\RktValLink{\$spaces}}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{rhs}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\Stttextless}{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{cons}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{string{-}{\Stttextmore}symbol}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{list{-}{\Stttextmore}string}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{list}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{op}\RktPn{)}\RktPn{)}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{rhs}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Our full expression rule looks like this:

\label{t:x28elem_x28chunk_x22x3cexprx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cexprx3ex3a1x22x29x29]{\plainlink{$<$expr$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr{-}binopable}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextless}or{\Stttextmore}}}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{try}}}\mbox{\hphantom{\Scribtexttt{x}}}\hyperref[t:x28elem_x28chunk_x22x3cfuncallx3ex3a1x22x29x29]{\plainlink{$<$funcall$>$}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{\$char}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{\$number}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{\$sidentifier}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}

\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextless}or{\Stttextmore}}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{try}}}\mbox{\hphantom{\Scribtexttt{x}}}\hyperref[t:x28elem_x28chunk_x22x3cvarx2dassignx3ex3a1x22x29x29]{\plainlink{$<$var{-}assign$>$}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktSym{\$string}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}seq}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktSym{\$expr{-}binopable}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextless}or{\Stttextmore}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{try}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$binop}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{v}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{apply}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{cons}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{v}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

The \Scribtexttt{\$expr{-}binopable} parser defines expressions that \textit{might}
have a binary operation after parsing the term. This is to prevent the
possiblity of binary operations after something like a variable assignment
which doesn{'}t make much sense.

In the \Scribtexttt{\$expr} rule, we try to parse a binary operation, and return an
empty list if it fails to parse. We{'}ve successfully eliminated
left{-}recursion!

When two rules reference each other recursively (like \Scribtexttt{\$binop} and
\Scribtexttt{\$expr} in this case) we say they{'}re mutually recursive. Mutual
recursion can become an issue in some situations. For instance, it can
lead to indirect left{-}recursion which is more subtle than the direct
left{-}recursion we{'}ve seen. But often when building parsers, mutual
recursion is useful for expressing certain parse rules.

Now we{'}ll define expression and argument lists.

\label{t:x28elem_x28chunk_x22x3cexprx2dlistx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cexprx2dlistx3ex3a1x22x29x29]{\plainlink{$<$expr{-}list$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr{-}list}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{sepBy}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}seq}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\},}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

\label{t:x28elem_x28chunk_x22x3cargx2dlistx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cargx2dlistx3ex3a1x22x29x29]{\plainlink{$<$arg{-}list$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$arg{-}list}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{sepBy}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}seq}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$sidentifier}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\sim$}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$sidentifier}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}seq}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\},}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

We{'}ll also include variable declarations.

\label{t:x28elem_x28chunk_x22x3cvarx2ddeclx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cvarx2ddeclx3ex3a1x22x29x29]{\plainlink{$<$var{-}decl$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$var{-}decl}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{intersperse{-}spaces}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{parser{-}seq}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$sidentifier}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$sidentifier}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{v}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{cons}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{def}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{v}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Similar to \Scribtexttt{\$identifier}, Parsack{'}s built{-}in \Scribtexttt{string} function
returns a list of characters rather than a string. Rather than converting
back to a string every time we call the function, we{'}ll write another
helper function to parse this way for us.

\label{t:x28elem_x28chunk_x22x3csstringx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3csstringx3ex3a1x22x29x29]{\plainlink{$<$sstring$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{sstring}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{s}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{string}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{s}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{compose}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{list{-}{\Stttextmore}string}}}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

We{'}ll use the \Scribtexttt{sstring} function for our return statement.

\label{t:x28elem_x28chunk_x22x3creturnx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3creturnx3ex3a1x22x29x29]{\plainlink{$<$return$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$return}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}one}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{sstring}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"return"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxx}}}\RktSym{\badlink{\RktValLink{\$spaces}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{$\sim${\Stttextmore}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{r}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{list}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{return}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{r}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

If statements require a bit more code, but are fairly simple to understand
as well.

\label{t:x28elem_x28chunk_x22x3cifx2dstmtx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cifx2dstmtx3ex3a1x22x29x29]{\plainlink{$<$if{-}stmt$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$if}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{intersperse{-}spaces}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{\badlink{\RktValLink{parser{-}seq}}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{sstring}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"if"}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{{\char`\_}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{if}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{between}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}(}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\})}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{between}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}{\char`\{}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}{\char`\}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$stmt{-}list}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextless}or{\Stttextmore}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{intersperse{-}spaces}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktSym{\badlink{\RktValLink{parser{-}seq}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{sstring}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"else"}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{{\char`\_}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{else}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{between}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}{\char`\{}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}{\char`\}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$stmt{-}list}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{$\sim$}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

We{'}ll use statement lists inside of our blocks.

\label{t:x28elem_x28chunk_x22x3cstmtx2dlistx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cstmtx2dlistx3ex3a1x22x29x29]{\plainlink{$<$stmt{-}list$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$stmt}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextless}or{\Stttextmore}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{try}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$if}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}one}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{$\sim${\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextless}or{\Stttextmore}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{try}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$return}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{try}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$var{-}decl}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$expr}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktSym{\badlink{\RktValLink{\$spaces}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\};}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\RktPn{)}\RktPn{)}\RktPn{)}

\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$stmt{-}list}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{many1}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$stmt}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

And finally, our top{-}level function definition rule is written like so:

\label{t:x28elem_x28chunk_x22x3cfuncx2ddefx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cfuncx2ddefx3ex3a1x22x29x29]{\plainlink{$<$func{-}def$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$func{-}def}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{{\Stttextmore}{\Stttextmore}=}}}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{intersperse{-}spaces}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktSym{\badlink{\RktValLink{parser{-}seq}}}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktSym{\$sidentifier}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktSym{\$sidentifier}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{between}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}(}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\})}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$arg{-}list}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{between}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}{\char`\{}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{char}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#{\char`\\}{\char`\}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parser{-}one}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\sim${\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$stmt{-}list}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\badlink{\RktValLink{\$spaces}}}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{lambda}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{r}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{return}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\badlink{\RktValLink{cons}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{fun}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{r}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

We{'}ll combine it into a file with the following structure.

\label{t:x28elem_x28chunk_x22x3cx2ax3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cx2ax3ex3a1x22x29x29]{\plainlink{$<$*$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{\badlink{\RktValLink{provide}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{parse{-}c}\RktPn{)}

\hyperref[t:x28elem_x28chunk_x22x3cincludesx3ex3a1x22x29x29]{\plainlink{$<$includes$>$}}

\hyperref[t:x28elem_x28chunk_x22x3cinterspersex2dspacesx3ex3a1x22x29x29]{\plainlink{$<$intersperse{-}spaces$>$}}

\hyperref[t:x28elem_x28chunk_x22x3csidentifierx3ex3a1x22x29x29]{\plainlink{$<$sidentifier$>$}}

\hyperref[t:x28elem_x28chunk_x22x3csstringx3ex3a1x22x29x29]{\plainlink{$<$sstring$>$}}

\mbox{\hphantom{\Scribtexttt{x}}}

\hyperref[t:x28elem_x28chunk_x22x3cnumberx3ex3a1x22x29x29]{\plainlink{$<$number$>$}}

\hyperref[t:x28elem_x28chunk_x22x3cstringx3ex3a1x22x29x29]{\plainlink{$<$string$>$}}

\hyperref[t:x28elem_x28chunk_x22x3ccharx3ex3a1x22x29x29]{\plainlink{$<$char$>$}}

\hyperref[t:x28elem_x28chunk_x22x3cbinopx3ex3a1x22x29x29]{\plainlink{$<$binop$>$}}

\hyperref[t:x28elem_x28chunk_x22x3cexprx3ex3a1x22x29x29]{\plainlink{$<$expr$>$}}

\hyperref[t:x28elem_x28chunk_x22x3cexprx2dlistx3ex3a1x22x29x29]{\plainlink{$<$expr{-}list$>$}}

\hyperref[t:x28elem_x28chunk_x22x3cargx2dlistx3ex3a1x22x29x29]{\plainlink{$<$arg{-}list$>$}}

\hyperref[t:x28elem_x28chunk_x22x3cvarx2ddeclx3ex3a1x22x29x29]{\plainlink{$<$var{-}decl$>$}}

\hyperref[t:x28elem_x28chunk_x22x3creturnx3ex3a1x22x29x29]{\plainlink{$<$return$>$}}

\hyperref[t:x28elem_x28chunk_x22x3cifx2dstmtx3ex3a1x22x29x29]{\plainlink{$<$if{-}stmt$>$}}

\hyperref[t:x28elem_x28chunk_x22x3cstmtx2dlistx3ex3a1x22x29x29]{\plainlink{$<$stmt{-}list$>$}}

\hyperref[t:x28elem_x28chunk_x22x3cfuncx2ddefx3ex3a1x22x29x29]{\plainlink{$<$func{-}def$>$}}

\mbox{\hphantom{\Scribtexttt{x}}}

\RktPn{(}\RktSym{\badlink{\RktValLink{define}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{parse{-}c}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{s}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{\badlink{\RktValLink{parse{-}result}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\$func{-}def}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{s}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

Most of this code is similar to the \Scribtexttt{yacc} parser code {-} the difference
between the two is the parser combinator is using more "Racket{-}isms" and
language features. While it requires more code in certain places, it{'}s an
intuitive way of writing parser code for a functional programmer, while
providing more control than \Scribtexttt{yacc}.

While the \Scribtexttt{yacc} parser was declarative as well, it didn{'}t expose any
lambdas or language functions to the user, instead relying on a series of
sophisticated macros (which can make debugging more difficult). After
learning about the low{-}level bind operator (\Scribtexttt{{\Stttextmore}{\Stttextmore}=}) and some parsers
(like \Scribtexttt{char}) a programmer can reason about a parser combinator and
build whatever abstractions they need. They can combine and use any
functions they want, and can easily extend the functionality with their
own combinators.

The parser combinator is capable of parsing a complex program like:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{require}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"c{-}parser{-}combinator{\hbox{\texttt{.}}}scrbl"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{parse{-}c}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"int}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{main(int}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{a)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\char`\{}}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktVal{long}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{x;}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktVal{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{=}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{2;}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktVal{if(x){\char`\{}}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxx}}}\RktVal{return}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{a;}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktVal{{\char`\}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\char`\{}}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxx}}}\RktVal{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{=}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{3;}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktVal{{\char`\}}}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktVal{return}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{f(1+a*x);}} \\
\hbox{\RktVal{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktVal{{\char`\}}"}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktErr{parse ERROR: at 4:18:75
unexpected: "\{"
  expected: "white space or ;"
  context...:
   /home/nc/.racket/6.12/pkgs/parsack/parsack/parsack.rkt:464:0: parse53
   [repeats 1 more time]
   /home/nc/.racket/6.12/pkgs/parsack/parsack/parsack.rkt:486:0: parse{-}result
   /usr/share/racket/collects/racket/private/more{-}scheme.rkt:148:2: call{-}with{-}break{-}parameterization
   .../more{-}scheme.rkt:261:28
   /usr/share/racket/pkgs/sandbox{-}lib/racket/sandbox.rkt:861:5: loop
}\end{SingleColumn}\end{SCodeFlow}

No book on language implementation is complete without a brief look into
parsing techniques. However, for the rest of the book, we will be using
s{-}expressions to represent our language since they{'}re a convenient
format to use to represent ASTs (especially in Racket). Writing an
s{-}expression parser is trivial, but since Racket has a built in \Scribtexttt{read}
function (which does all necessary parsing into an s{-}expression), we{'}ll be
freed from having to write any parsing code for the rest of the
implemlentations.

\sectionNewpage

\Ssection{Interpreters}{Interpreters}\label{t:x28part_x22Interpretersx22x29}

We will begin with a brief look at interpreters. Simple interpreters are
easier to implement than simpler compilers, so they{'}re often used for
prototyping language implementations.

We{'}ll start with the simplest type of interpreter, a graph walking interpreter.

Lisp is extermely simple to implement in Lisp itself. A classic implementation
can be found in [\hyperref[t:x28cite_x22SICPx22x29]{SICP}] (Chapter 4, the Metacircular Evaluator), which
defines the interpreter elegently in terms of \Scribtexttt{eval} and \Scribtexttt{apply},
while allowing the language implementor to leverage internal functions in
the host language to evaluate code. Later chapters implement a simple
compiler in terms of a virtual machine.

However, the original Lisp interpreter written in Lisp is only a single page
(reproduced and ported to Racket below) [\hyperref[t:x28cite_x22McCarthyx2c_1978x22x29]{McCarthy, 1978}]:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{atom{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{not}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{list{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{assoc}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cond}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{null{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{assoc}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{pairup}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{v}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cond}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{null{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{else}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{v}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{pairup}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{v}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cond}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{atom{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{cond}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{t}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#t}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{number{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{else}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{assoc}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{atom{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{cond}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{quote}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{car}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{cdr}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{cadr}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{caddr}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{caddr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{caar}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{caar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{cadar}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{cadar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{caddar}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caddar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{atom{\hbox{\texttt{?}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{atom{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{null{\hbox{\texttt{?}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{null{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{cons}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caddr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{eq{\hbox{\texttt{?}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caddr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{*}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caddr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{{-}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caddr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{cond}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{letrec}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{evcond}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{u}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{cond}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{evcond}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{evcond}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{assoc}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{lambda}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caddar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{letrec}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{ffappend}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{u}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{v}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{cond}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{null{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{v}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{ffappend}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{v}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{evlis}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{u}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{cond}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{null{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{evlis}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{u}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{ffappend}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{pairup}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{evlis}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{label}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{caddar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cadar}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{a}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktMeta{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktMeta{a}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}a}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{n}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{cond}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{7}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{42}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{lisp{-}eval}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{(}\RktMeta{label}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{fac}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{n}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{cond}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{fac}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{7}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{5040}\end{SingleColumn}\end{SCodeFlow}

Granted, this code could possibly be refactored into some functions, and a few
helper functions could make it easier to read. However, the \textit{entire
implementation for a simple Lisp is one page}. This is one of the powerful
features of Lisp. It{'}s a language with a small kernel that{'}s easy to implement.
Once the kernel is impelmented, every feature expected in a high{-}level
language is easy to add. Lisp isn{'}t limited in expressiveness because of
its simple design. The design just makes it easy to reason about.

Interpreters are simple to build in Lisp, and Racket makes it even easier
with the ability to mix different languages implemented in Racket
together. These different "languages" are still compatable with each other
(since they all have Racket interpreters in the end). We can mix standard
Racket with typed and lazy Racket in a single project, and all the code
will still work together.

We{'}ll briefly look at a few ways interpreter implementations are sped up
through compilation.

\Ssubsection{Graph walking}{Graph walking}\label{t:x28part_x22Graphx5fwalkingx22x29}

Graph walking interpreters are straightforward to implement. A few minor
transformations are made on the IR, then the interpreter executes the
graph directly. Since the source closely represents the runtime structure
of the code, runtime errors are easier debug. Finally, metaprogramming and
reflection are simple since no extra metadata has to be stored to ensure
the runtime environment has access to the information it needs.

The downside of graph walking interpreters is their poor performance.
Traversing a graph generally entails following pointers from node to node,
which is far slower to execute on modern CPU{'}s than sequences of (mostly)
contiguous instructions. Many interpreted programming language
implementations start out as graph walking interpreters, since they{'}re
quick to implement. Eventually, most compile to a bytecode that is
interpreted on a virtual machine (VM) to improve performance.

Essentially, we{'}ve already implemented a graph walking interpreter with the
Lisp implementation on the last page. Lisp code is already a tree once
\Scribtexttt{(read)} in, and we simply traverse the tree to execute our program.

\Ssubsection{Virtual Machine}{Virtual Machine}\label{t:x28part_x22Virtualx5fMachinex22x29}

Once a language has a graph interpreter, the language implementer will
want to improve its performance. The next step is to design a virtual
machine (VM) for the language that maps closely to real hardware, without
drifting far from the semantics of the interpreted language. The goal of
the bytecode is to be an intermediate target between the source and real
machine code so the from source to the VM{'}s instructions (called bytecode)
is a simple and fast.

\includegraphics[scale=0.5]{rkttmp0e764554d0ddbfc25a4d4270b1435c61c51010b3.png}

While this strategy requires initially processing to convert the
source to bytecode, it can improve interpretation speed tremendously. To
prevent slow startup times caused by bytecode compilation, some languages
require a separate compile step to generate a bytecode file. This bytecode
file is then directly interpreted by the virtual machine implementation.
One example of this is Java, which requires a compile step with \Scribtexttt{javac}
(the Java compiler) to generate a \Scribtexttt{{\hbox{\texttt{.}}}java} file which can then be
interpreted by the JVM implementation installed on the machine. Even
languages like Python will generate bytecode files (\Scribtexttt{{\hbox{\texttt{.}}}pyc}) and cache
them for installed libraries to improve import speed.

Some languages like Ruby and Lua don{'}t bother with caching the bytecode
and re{-}parse the file every time it is loaded. This decision is made
because performance isn{'}t a focus (in Ruby{'}s case), or because the
language is meant for embedded purposes with small source files (in Lua{'}s
case).

It{'}s important to realize that the compilation step happens. The term
"interpreter" can be misleading when most language "interpreters" are
actually bytecode interpreters that require a compilation step to convert
source into VM bytecode. While the bytecode interpreter is a proper
interpreter (usually), modern interpreters can be better described as
naive compilers that feed the result into a bytecode interpreter.

\Ssubsubsection{Stack{-}based}{Stack{-}based}\label{t:x28part_x22Stackx2dbasedx22x29}

The simplest virtual machine model is a stack{-}based machine. This
design of virtual machine has no registers, instead relying on pushing and
popping from the runtime stack. All operations affect the top elements in
the stack, and new computations are pushed onto the stack when completed.

A simple stack{-}based bytecode might look like:

\hspace*{\fill}\\\Scribtexttt{push 3}\hspace*{\fill}\\\Scribtexttt{push 7}\hspace*{\fill}\\\Scribtexttt{add}\hspace*{\fill}\\\Scribtexttt{push 2}\hspace*{\fill}\\\Scribtexttt{div}\hspace*{\fill}\\

Which equates to the operations,

\includegraphics[scale=0.5]{rkttmp4ab094d3a4c129faf5fe5859a65e4fa953b7f41b.png}

After each result from an operation is computed, it placed on the top of
the stack, so the next operation can access it. Stack machines are popular
because the simple design is appealing. Register allocation is not an
issue, and it is easy to reason about stack operations. Stack{-}based VMs do
have a slight performance loss and require more instructions than
register{-}based VMs.

\Ssubsubsection{Register{-}based}{Register{-}based}\label{t:x28part_x22Registerx2dbasedx22x29}

Register{-}based VMs require fewer significantly fewer instruction for
programs, and are faster than stack{-}based machines [\hyperref[t:x28cite_x22Yunhex2c_2005x22x29]{Yunhe, 2005}] (due
to the fact that a register{-}based VM reflects the architecture of a real
machine more than a stack{-}based VM does).

Register{-}based VMs are less common than stack{-}based VMs. The most notable
register{-}based VMs implementations are LuaJIT and the V8 JavaScript
implementation in Chrome.

\Ssubsubsection{JIT compilation}{JIT compilation}\label{t:x28part_x22JITx5fcompilationx22x29}

The disadvantage of a naive stack or register{-}based interpreter written
another language is that interpretation of virtual machine bytecode is
inherently slower than native code. Machine code written specifically for
the target CPU{'}s architecture will run faster the machine code that is
interpreting some other bytecode. To mitigate the problem, the fastest
interpreters compile portions of the interpreted bytecode directly to
machine code at runtime.

This technique (known as just{-}in{-}time compilation), is what makes many modern
interpreters fast. LuaJit, the V8 JavaScript interpreter, the Java Virtual Machine,
and PyPy (a JITted Python implementation) are some examples of popular
JIT implementations.

Since the code is compiled during runtime, the interpreters are very
sophisticated and can be difficult to debug (since part of the interpreted
code is VM bytecode and part is be machine code). While simplicity is
lost, JITs can perform optimizations that are impossible for conventional
compilers.

Tracing JITs analyze the program as it is interpreted as bytecode. When it
finds a "hot spot" (i.e. a sequence of instructions that repeatedly
executed), it compiles the bytecode instructions to native instructions so
they execute faster.

If a module was dynamically loaded at runtime, and a function was
frequently called in the bytecode, the tracing JIT could
inline\NoteBox{\NoteContent{Inlining is the process of copying the code inside a function
to where the function is called, so there{'}s less overhead from a function
call and certain other optimizations are possible}} the bytecode
instructions and compile the whole sequence to
machine code, which is something a conventional ahead{-}of{-}time (AOT)
compiler simply couldn{'}t do. It is impossible for an AOT compiler to
determine which module will be dynamically loaded.

The dynamism of JITs is quite fascinating, and its interesting how the
interpreter can "learn" to make code faster over time. But JIT{'}s are a
sophisticated and advanced subject, requiring a book of their own.

JITs attempt to take advantage of the best aspects of compliers (speed)
and interpreters (flexibility), with a tradeoff of complexity. With
a basic understand of interpretation, we will move onto the final portion
of this book which focuses on compilers.

\sectionNewpage

\Ssection{Compilers}{Compilers}\label{t:x28part_x22Compilersx22x29}

This final portion of the book will focus on compilers. Compilers convert the
source language to a target language (generally assembly or VM bytecode).
The process is performed in a series of passes, starting with parsing,
semantic analysis, before being passed to a series of optimization passes,
and eventually a code{-}generation pass.

The later passes in a compiler (called the backend) are where a compiler really
diverges from an interpreter. Both an interpreter and a compiler may share a
front{-}end (i.e. the parsing/semantic analysis passes), but after that
point they deviate in what they do. An interpreter will take the
high{-}level IR from the from the front{-}end begin interpreting the IR
directly (unless it compiles to bytecode, in which case the interpretation
happens on the bytecode).

Since compilers read and compile code once, they can do sophisticated and
computationally expensive optimization passes that aren{'}t available to
interpreters for performance reasons. Fast compilers are important, but
slower compilers are acceptable when generating a release binary that
needs a faster execution time.

An overview of the compiler pipeline we use for our compiler
implementation is as follow:

\includegraphics[scale=0.5]{rkttmpb5f4009a8299620bd7973e12ea0c7d206b91cb3c.png}

\Ssubsection{Nanopass framework}{Nanopass framework}\label{t:x28part_x22Nanopassx5fframeworkx22x29}

Compilers are convenient to architect, since they{'}re almost all designed
as a series of passes in a pipeline. This makes projects easy to reason
about since the structure of the project is clear and well defined. In toy
compilers and education courses, compiler developers will sometimes build
micropass compilers {-} compilers that are composed of many small passes
that each perform trivial transformations to the intermediate
representation. However, most real{-}world compilers have few sophisticated
passes that perform multiple transformations on the intermediate
representation. This makes them difficult to understand and maintain over
time [\hyperref[t:x28cite_x22Sarkarx2c_2005x22x29]{Sarkar, 2005}].

Micropass compilers are preferred since every pass can be understood,
tweaked, and quickly replaced. However, each pass implicitly expects
a correct input IR, and does no verification to assert the output IR is
valid. When an incorrect IR is generated and isn{'}t caught early in the
pipeline, subtly incorrect IRs can propagate downstream before breaking
a later pass. These types of errors can be hard to debug in a micropass
compiler, since it is difficult to find the pass that generated the
invalid IR.

Besides debuggablity, micropass compilers are also painfully slow. Since
they generate a new tree with every pass (instead of transforming it
in{-}place). Each pass must navigate the whole tree for every pass. This
problem becomes serious on large, practical projects that compile large,
real{-}world codebases.

The Nanopass framework is a domain specific language that attempts to
mitigate these issues by formally defining each pass{'}s input and output
languages, and using an efficient record{-}based data structure for storing
passes. Along with solving these problems, it also provides nice syntactic
sugar to rid the compiler code of the boilerplate micropass compilers
sometimes accumulate.

While primarly used for educational purposes, the nanopass framework is
viable for real{-}world compilers as well. The Chez Scheme implementation is
a Scheme implementation developed by Cisco, and is one of the most
performant Scheme implementations available. The backend for Chez was
recently reimplemented in Nanopass [\hyperref[t:x28cite_x22Keepx2c_2013x22x29]{Keep, 2013}], [\hyperref[t:x28cite_x22Keepx2c_2012x22x29]{Keep, 2012}],
so it could generate faster executables without huge performance loss on
compile times (which is an impressive feat considering Chez is an
extremely fast compiler).

In our implementation we will use the Nanopass framework, since it{'}s
a viable framework for building compilers, and allows us defines passes in
a syntax that{'}s easy to understand.

We{'}ll start by looking at a language that might be the input for a pass.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{require}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{nanopass/base}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{var{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{v}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{symbol{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{v}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{literal{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{l}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{or}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{string{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{l}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{number{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{l}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define{-}language}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{L0}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{terminals}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{var}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{v}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{literal}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{l}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{body}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{v}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{l}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{begin}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{v*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{body*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{body}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}\end{SingleColumn}\end{SCodeFlow}

When defining terminals, the names are significant. The Nanopass expects
a prediciate for every terminal (so \Scribtexttt{var} expects \Scribtexttt{var{\hbox{\texttt{?}}}} to exist
and \Scribtexttt{literal} expects \Scribtexttt{literal{\hbox{\texttt{?}}}} to exist). The symbol in
parentheses beside the variable names a metavariable which can be used in
the non{-}terminal productions (e.g. the definitions inside of \Scribtexttt{Expr}).

Next we define our non{-}terminals, and their production rules. In this
language we{'}ll make it a tiny subset of Scheme. When writing production
rules, the names are meaningful. Symbols like \Scribtexttt{*}, \Scribtexttt{\$}, \Scribtexttt{{\char'136}} and
numbers are ignored, but the rest of the name is significant. When using
the \Scribtexttt{v} metavariable, Nanopass will expect to find a variable and will
ensure that it is a variable using the \Scribtexttt{var{\hbox{\texttt{?}}}} predicate.

The ellipses are used to notate that the previously listed variable is
expected to be defined zero or more times.

Now we{'}ll consider transforming this language to another. The
transformation we{'}ll perform will wrap every sequence of multiple
expressions (i.e. lambda bodies) \Scribtexttt{begin} block if they have more than
one expression.

First we{'}ll define our target language. Since it{'}s just a variation
on the previous language we can extend \Scribtexttt{L0} to remove multiple
expressions for the body.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define{-}language}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{L1}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{extends}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{L0}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{body}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{v*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{body*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{body}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{v*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{body}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}\end{SingleColumn}\end{SCodeFlow}

Rather than rewriting the whole language, we can extend another language,
remove unnecessary productions (in the \Scribtexttt{{-}} section), and add new
productions (in the \Scribtexttt{+} section).

Now we{'}ll implement the pass that does the transformation.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define{-}pass}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{beginify}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{L0}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{ir}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{-}{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{L1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{definitions}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{with{-}output{-}language}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{L1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{Expr}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{maybe{-}beginify}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{\Stttextless}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{length}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktMeta{}\RktVal{{\textasciigrave}}\RktPn{(}\RktMeta{begin}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{,}\RktPn{(}\RktMeta{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{e}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{ir}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{-}{\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{,}\RktMeta{v*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{,}\RktMeta{body*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{,}\RktMeta{body}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktVal{{\textasciigrave}}\RktPn{(}\RktMeta{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{,}\RktMeta{v*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktMeta{,}\RktPn{(}\RktMeta{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{maybe{-}beginify}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{append}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{body*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{list}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{body}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}\end{SingleColumn}\end{SCodeFlow}

Syntactically we{'}re working with s{-}expressions, but in reality, nanopass
is converting them to records internally. It{'}s just nicer to deal with
s{-}expressions, so it automatically converts records to simplify the
transformations. \Scribtexttt{with{-}output{-}language} has to surround our definition
of \Scribtexttt{maybe{-}begininfy} since it rebinds the quasiquote \Scribtexttt{}\Scribtexttt{{`}}\Scribtexttt{} to make it
generate nanopass language records.

Nanopass has a plethora of other features, but this brief introduction
will be enough to give a general understanding of what the passes do. For
more information, read the [\hyperref[t:x28cite_x22nanopassx2dracket_documentationx22x29]{nanopass{-}racket documentation}] and
[\hyperref[t:x28cite_x22Keepx2c_2012x22x29]{Keep, 2012}]

For the sake of brevity, we will not define intermediate languages, and
will instead focus on the transformation passes. The code for the fully
functioning compiler can be found at
\href{https://github.com/charles-l/comp/tree/master/fir}{\Snolinkurl{https://github.com/charles-l/comp/tree/master/fir}}.

\Ssubsection{Desugaring}{Desugaring}\label{t:x28part_x22Desugaringx22x29}

Most languages have shorthand syntax for common operations, like creating
literal arrays or hashes, referencing elements in a data structure with
square brackets, or using operations like \Scribtexttt{+=} or \Scribtexttt{++} (which are
just shorthand for incrementing a value by an amount and reassigning the
variable with the new value).

The shorthand syntax (known as \textit{syntactic sugar}), creates
extraneous expressions that must be handled by passes further down the
pipeline. These expressions can be simplified to a semantic equivalent in
a smaller core language with the same meaning (albeit with more
verbose syntax).

For instance, the creation of a \Scribtexttt{vector} might be converted from:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{vector}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{a}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{b}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{c}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{d}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}\#(a b c d)}\end{SingleColumn}\end{SCodeFlow}

to:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tmpvec}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{make{-}vector}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{4}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{vector{-}set{\hbox{\texttt{!}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tmpvec}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{a}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{vector{-}set{\hbox{\texttt{!}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tmpvec}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{b}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{vector{-}set{\hbox{\texttt{!}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tmpvec}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{c}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{vector{-}set{\hbox{\texttt{!}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{tmpvec}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{d}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{tmpvec}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}\#(a b c d)}\end{SingleColumn}\end{SCodeFlow}

For Racket, it is a bit contrived to have the compiler perform desugaring,
since most language features are implemented as macros. Macros even allow
the programmer do define their own syntactic sugar. However, in most
languages where the syntax isn{'}t as customizable, desugaring is a useful
step that simplifies the structure of later passes.

\Ssubsection{The IR}{The IR}\label{t:x28part_x22Thex5fIRx22x29}

After semantically checking the parse tree, the compiler converts the
parse tree into an intermediate representation (IR). The IR is designed to
make optimization and analysis easier. After the optimization and analysis
passes, the compiler generates machine code from the IR. Depending on the
complexity of the IR, there may be passes to convert the IR into
a lower{-}level IR that maps more closely to machine code.

Functional compilers regularly use continuation{-}passing style (CPS) or
A{-}normal form (ANF) as an intermediate representation.

\Ssubsubsection{A{-}normal form}{A{-}normal form}\label{t:x28part_x22Ax2dnormalx5fformx22x29}

We will be using ANF in our implementation.

A{-}normal form was introduced in [\hyperref[t:x28cite_x22Flanaganx2c_1993x22x29]{Flanagan, 1993}], as an alternative
to CPS since CPS has clunky syntax and encodes some redundant information.
ANF is equivalent to CPS, and doesn{'}t require complicated transformation
passes.

In ANF, every subexpression is reduced and lifted into its own temporary
variable. This means that function call arguments only reference variables
or literals, and cannot be expressions themselves. When every
subexpression is an immediate value, translation to machine code is
trivial.

Consider the following program:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{fib}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{or}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktVal{1}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{fib}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{fib}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{fib}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{10}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{55}\end{SingleColumn}\end{SCodeFlow}

If we were to rewrite it in ANF:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{anf{-}fib}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{t1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{t2}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{t3}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{or}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{t1}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{t2}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{t3}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktVal{1}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{t4}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{t5}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{{-}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{t6}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{anf{-}fib}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{t4}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{t7}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{anf{-}fib}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{t5}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{t6}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{t7}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{anf{-}fib}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{10}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{55}\end{SingleColumn}\end{SCodeFlow}

In this example the variables are named with temporaries since a human
isn{'}t expected to write in ANF, since the compiler transforms code to ANF
automatically.

The Scheme compiler we implement will include a pass that converts the
program into ANF form. It is implemented recursively by ensuring that
subexpressions are eliminated and replaced with temporary variables (these
temporary variable names are generated with \Scribtexttt{(gensym)}, a built{-}in
Racket function that generates fresh variable names).

\label{t:x28elem_x28chunk_x22x3cconvertx2dtox2danfx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cconvertx2dtox2danfx3ex3a1x22x29x29]{\plainlink{$<$convert{-}to{-}anf$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{define{-}pass}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{convert{-}to{-}anf}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{L1}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{ir}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{L1{\hbox{\texttt{.}}}1}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{definitions}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{value{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{m}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{match}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{m}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktPn{(}\RktSym{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{constant{\hbox{\texttt{?}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#t}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktPn{(}\RktSym{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{variable{\hbox{\texttt{?}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#t}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{\#f}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{with{-}output{-}language}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{L1{\hbox{\texttt{.}}}1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{maybe{-}normalize}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{gen{-}body}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{value{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktSym{gen{-}body}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{tmp{-}var}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{gensym}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{tmp{-}var}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktRdr{,}\RktPn{(}\RktSym{gen{-}body}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{tmp{-}var}\RktPn{)}\RktVal{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{maybe{-}normalize*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{gen{-}body}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{match}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e*}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{gen{-}body}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktVal{{\textasciigrave}}\RktVal{(}\RktRdr{,}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}} }\RktRdr{,}\RktSym{rest}\RktVal{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{maybe{-}normalize}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{t}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktPn{(}\RktSym{maybe{-}normalize*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{rest}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{t*}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktPn{(}\RktSym{gen{-}body}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t*}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{ir}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{[}\RktSym{e1}\RktPn{]}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{[}\RktSym{e2}\RktPn{]}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{maybe{-}normalize}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e0}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{v}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{v}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e1}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e2}\RktVal{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktPn{(}\RktRdr{,}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{maybe{-}normalize}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{t}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{maybe{-}normalize*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e1}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{t*}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktRdr{,}\RktSym{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{t*}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

\Ssubsection{$\alpha${-}conversion}{$\alpha${-}conversion}\label{t:x28part_x22x5fx2dconversionx22x29}

In $\lambda${-}calculus, two programs may be equivalent, despite having different
binding names. For instance, the identify function, is the identify
function no matter what the argument is named.

\texMathDisplay{\lambda i \; . \; i}
\texMathDisplay{\lambda j \; . \; j}

These functions are $\alpha${-}equivalent (i.e. they{'}re semantically equivalent),
and we can make them syntactically equivalent by transforming them using
$\alpha${-}conversion (alpha conversion). For instance, if we rename \texMathInline{j} to
\texMathInline{i} in the second example,

\texMathDisplay{\lambda j \; . \; j \Rightarrow \lambda i \; . \; i}

it is syntactically equivalent to the first equation.

$\alpha${-}conversion is not only useful for checking equivalence. It can also be
used to rename variables. When variables are shadowed, the order in which
they appear is significant.

\texMathDisplay{\lambda x, y \; . \; ((\lambda x \; . \; x) \; y) + x}

To prevent later passes from having to track environment information to
properly shadow variables, $\alpha${-}conversion is done to ensure each variable
name in the program is unique. For instance, the previous expression could
be converted into the following to differentiate between shadowed
variables:

\texMathDisplay{\lambda x.0, y \; . \; ((\lambda x.1 \; . \; x.1) \; y) + x.0}

The pass could be implemented as follows (this pass also does basic
desugaring):

\label{t:x28elem_x28chunk_x22x3cdesugarx2dandx2dalphax2dconversionx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3cdesugarx2dandx2dalphax2dconversionx3ex3a1x22x29x29]{\plainlink{$<$desugar{-}and{-}alpha{-}conversion$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{define{-}pass}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{parse{-}and{-}desugar}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{e}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{L0}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{definitions}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{in{-}env{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{hash{-}has{-}key{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{extend{-}env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{in{-}env{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{hash{-}set}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{add1}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{hash{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{hash{-}set}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{0}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{var{-}name}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\%name{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{e}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{string{-}{\Stttextmore}symbol}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktSym{string{-}append}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{symbol{-}{\Stttextmore}string}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktVal{"{\hbox{\texttt{.}}}"}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{number{-}{\Stttextmore}string}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{hash{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{maybe{-}beginify}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{=}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{length}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{begin}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{Expr*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{map}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{curryr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e*}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{with{-}output{-}language}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{L0}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{expand{-}let}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{let{-}e}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{match}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{let{-}e}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{(}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{bindings}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{body}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{env*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{foldl}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{extend{-}env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{n}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxx}}}\RktSym{env}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxx}}}\RktSym{bindings}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{expand{-}bindings}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{b}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktPn{(}\RktSym{match}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{b}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxx}}}\RktPn{(}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{maybe{-}beginify}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{body}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env*}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxx}}}\RktPn{(}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{(}\RktRdr{,}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e}\RktVal{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}} }\RktRdr{,}\RktSym{rest}\RktVal{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktPn{(}\RktSym{unless}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{or}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{variable{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{type{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\RktPn{(}\RktSym{error}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"let binding is invalid"}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktRdr{,}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{t}\RktVal{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{(}\RktSym{var{-}name}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktRdr{,}\RktPn{(}\RktSym{expand{-}bindings}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{rest}\RktPn{)}\RktVal{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\RktPn{(}\RktSym{expand{-}bindings}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{bindings}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{(}\RktSym{else}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktPn{(}\RktSym{error}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"invalid let form"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{let{-}e}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{match}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktPn{(}\RktSym{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{constant{\hbox{\texttt{?}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktPn{(}\RktSym{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{variable{\hbox{\texttt{?}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{var{-}name}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{begin}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{exprs}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{Expr*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{exprs}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{begin}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{(}\RktSym{drop{-}right}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{(}\RktSym{last}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktVal{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{a}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{b}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{c}\RktVal{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{a}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{b}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{c}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\RktVal{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktVal{{\textasciigrave}}\RktVal{(}\RktRdr{,}\RktPn{(}\RktSym{or}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{$\lambda$}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{type}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{args}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{body}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{when}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{check{-}duplicates}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{args}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{error}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"duplicate arg names"}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{env*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{foldl}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{extend{-}env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{n}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktSym{env}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktSym{args}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{type}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{(}\RktRdr{,}\RktSym{args}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{maybe{-}beginify}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{body}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env*}\RktPn{)}\RktVal{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{{\char`\_}}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{expand{-}let}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktVal{{\textasciigrave}}\RktVal{(}\RktRdr{,}\RktSym{f}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{args}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktRdr{,}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{f}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{(}\RktSym{Expr*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{args}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{hash}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

\Ssubsection{Type checking}{Type checking}\label{t:x28part_x22Typex5fcheckingx22x29}

Since the Scheme we implement includes type information in the source code
we will include a pass that does basic type{-}checking, and discards type
information for later passes (since it{'}s irrelevent in later stages in the
pipeline). Type{-}checking can be implemented as a sort of
pseudo{-}interpreter that evaluates and checks type information in the
program.

Type checking will track types in a symbol{-}table called \Scribtexttt{env}.

\label{t:x28elem_x28chunk_x22x3ctypex2dcheckx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3ctypex2dcheckx3ex3a1x22x29x29]{\plainlink{$<$type{-}check$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{define{-}pass}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{type{-}check{-}and{-}discard{-}type{-}info}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{L0}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{ir}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{L1}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{definitions}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{check}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{xt}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{infer}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{unless}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{equal{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{xt}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktSym{error}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"expected"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"to be of type"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"but was"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{xt}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{xt}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{infer}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{ir}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{type}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktRdr{,}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{env{-}lookup{-}type}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktRdr{,}\RktSym{c}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{match}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{c}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{number{\hbox{\texttt{?}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{int}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{boolean{\hbox{\texttt{?}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{bool}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{char{\hbox{\texttt{?}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{char}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktPn{(}\RktSym{begin}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{infer}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e1}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e2}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{check}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{bool}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{t1}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{infer}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{t2}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{infer}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e2}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{unless}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{equal{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t2}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktSym{error}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"if statement paths must return same type, but got"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t1}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"and"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t2}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{t1}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktRdr{,}\RktSym{x*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{body}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{env*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{foldl}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{c}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{env{-}add}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{c}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{c}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktSym{env}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{map}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{binding}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{n}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\RktSym{x*}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{drop{-}right}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{check}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{body}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{last}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktSym{t}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{body}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{env*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{env{-}add}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{binding}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{check}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{infer}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{body}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env*}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktPn{(}\RktRdr{,}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktSym{let*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{fty}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{infer}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{rargsty}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{map}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{curryr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{infer}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e1}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxx}}}\RktPn{(}\RktSym{argsty}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{drop{-}right}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cdr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{fty}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{unless}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{equal{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{argsty}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{rargsty}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{(}\RktSym{error}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"function has incorrect type {-} expecting args of type"}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktSym{argsty}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktVal{"but got"}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktSym{rargsty}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktVal{"for"}

\mbox{\hphantom{\Scribtexttt{xxxxxxxx}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e1}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktPn{(}\RktSym{last}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{fty}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{ir}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{[}\RktSym{e}\RktPn{]}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{body}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\RktRdr{,}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{body}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{env{-}add}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{env}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{binding}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{t}\RktPn{)}\RktPn{)}\RktPn{)}\RktVal{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxx}}}\RktPn{(}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktRdr{,}\RktSym{x*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktPn{[}\RktSym{body}\RktPn{]}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{(}\RktRdr{,}\RktSym{x*}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{body}\RktVal{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{infer}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{ir}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{hash}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{ir}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{hash}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

\Ssubsection{Functional compiler optimizations}{Functional compiler optimizations}\label{t:x28part_x22Functionalx5fcompilerx5foptimizationsx22x29}

Most of the passes in a real{-}world compiler{'}s backend are dedicated to code
optimization. The term code optimization is a bit misleading, since it
doesn{'}t result in optimal code. It generates code that may be more
performant because of transformations based on heuristics. However, even
though the code isn{'}t optimal, these heuristics can be valuable for
improving the runtime performance of generated code.

\Ssubsubsection{Inlining}{Inlining}\label{t:x28part_x22Inliningx22x29}

The most fundamental optimization is inlining, which is the process of
copying the code for a function directly to the call site. This lowers the overhead
for a function call, and makes other optimizations possible since the function
is no longer a black box.

\includegraphics[scale=0.5]{rkttmpde38ade67dde56fe1588b031b643997da38e2c8d.png}

\Ssubsubsection{Partial evaluation}{Partial evaluation}\label{t:x28part_x22Partialx5fevaluationx22x29}

If we look at the following code, we can hand optimize a few things.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{+widget{-}price+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{widget{-}price{-}with{-}tax}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{+widget{-}price+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0{\hbox{\texttt{.}}}06}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{+widget{-}price+}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{widget{-}price{-}with{-}tax}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{3{\hbox{\texttt{.}}}18}\end{SingleColumn}\end{SCodeFlow}

Given \Scribtexttt{+widget{-}price+} stays constant throughout the program, the value
of \Scribtexttt{(widget{-}price{-}with{-}tax)} will be the same number in every case.
Rather than recalculating it ever time we call the function, we can
determine statically (i.e. at compile time) that the widget
price is 3.18.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{widget{-}price{-}with{-}tax}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktVal{3{\hbox{\texttt{.}}}18}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{widget{-}price{-}with{-}tax}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{3{\hbox{\texttt{.}}}18}\end{SingleColumn}\end{SCodeFlow}

In this case, we were just dealing with constants, but partial evaluation is even more
powerful than that. For instance, an expression comprised of pure function could be
evaluated at runtime so as little code is run at runtime as possible.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{+widget{-}price+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{widget{-}price{-}with{-}tax}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{+widget{-}price+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0{\hbox{\texttt{.}}}06}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{+widget{-}price+}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{my{-}new{-}widget}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktMeta{price}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{widget{-}price{-}with{-}tax}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(my{-}new{-}widget price 3{\hbox{\texttt{.}}}18)}\end{SingleColumn}\end{SCodeFlow}

Since all the necessary information for this program is available to the compiler at runtime
it could partially evaluate this example to:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktMeta{my{-}new{-}widget}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{price}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3{\hbox{\texttt{.}}}18}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}(my{-}new{-}widget price 3{\hbox{\texttt{.}}}18)}\end{SingleColumn}\end{SCodeFlow}

\Ssubsubsection{Lambda{-}lifting}{Lambda{-}lifting}\label{t:x28part_x22Lambdax2dliftingx22x29}

Arguably not really an optimization, lambda{-}lifting is a code
transformation that attempts to eliminate closures (and must be done to
move functions outside of their inline definitions since defining inner
functions in assembly doesn{'}t make much sense). In our implementation, we
don{'}t support closures, so lambda{-}lifting is a simple operation.

\label{t:x28elem_x28chunk_x22x3clambdax2dliftingx3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3clambdax2dliftingx3ex3a1x22x29x29]{\plainlink{$<$lambda{-}lifting$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{define{-}pass}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{lift{-}lambdas}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{L1{\hbox{\texttt{.}}}1}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{ir}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{L2}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\RktPn{(}\RktSym{definitions}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*fs*}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{with{-}output{-}language}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{L2}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{make{-}func{\hbox{\texttt{!}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{l}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{body}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{set{\hbox{\texttt{!}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*fs*}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{label}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{l}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{(}\RktRdr{,}\RktSym{x*}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{body}\RktVal{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*fs*}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{ir}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktRdr{,}\RktSym{x*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{body}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{l}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{gensym}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{lambda}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{make{-}func{\hbox{\texttt{!}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{l}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{body}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{lref}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{l}\RktVal{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{ir}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktVal{{\textasciigrave}}\RktVal{(}\RktVal{program}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{(}\RktVal{label}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{program{\char`\_}entry}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{(}\RktVal{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e}\RktVal{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{*fs*}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktVal{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

We defined a new terminal called \Scribtexttt{program} which is a list of labels
and their associated lambdas. Generating machine code is then a simple
matter of emitting the function name as label, followed by its body.

\Ssubsubsection{Deforestation}{Deforestation}\label{t:x28part_x22Deforestationx22x29}

In functional programming, loops are generally discouraged since they{'}re hard to write and
difficult to reason about. Instead, functional languages encourage the use of \Scribtexttt{map},
\Scribtexttt{filter}, and \Scribtexttt{reduce} (or \Scribtexttt{foldl}).

For instance, to list all the hobbits with names that end with {'}r{'}:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{require}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{srfi/13}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{*names*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{{\textquotesingle}}\RktPn{(}\RktVal{"Thorin"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Fili"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Kili"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Balin"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Dwalin"}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktVal{"Oin"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Gloin"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Dori"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Nori"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Ori"}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxx}}}\RktMeta{}\RktVal{"Bifur"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Bofur"}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"Bombur"}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{map}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{string{-}reverse}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{filter}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{s}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{string{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{s}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\}r}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{map}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{string{-}reverse}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{map}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{string{-}downcase}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{*names*}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}("bifur" "bofur" "bombur")}\end{SingleColumn}\end{SCodeFlow}

Besides the fact that using a \Scribtexttt{string{-}reverse} is an extremely wasteful way to
check the first letter of a string, we{'}re also constructing many intermediate lists that
we never even use. Every \Scribtexttt{map} call generates a brand new list, and throws away the
previous. We can optimize these functions with deforestation.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{filter{-}map}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{s}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{and}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{string{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{compose}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{string{-}reverse}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{string{-}downcase}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{s}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{\#{\char`\\}r}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{string{-}downcase}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{s}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{*names*}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}("bifur" "bofur" "bombur")}\end{SingleColumn}\end{SCodeFlow}

While it is difficult to understand this code, it only loops through one list, and only
constructs one new list. In the previous example, it looped through the same list 4 times,
and constructed 4 intermediate lists that it threw away. This is a hugely valuable
optimization for functional languages since it has the potential to massively cut down on
computation time for processing large lists.

\Ssubsection{Data{-}flow and Control{-}flow analysis}{Data{-}flow and Control{-}flow analysis}\label{t:x28part_x22Datax2dflowx5fandx5fControlx2dflowx5fanalysisx22x29}

Data{-}flow and control{-}flow analysis passes determine information about
program control flow and variable usage. Commonly, data{-}flow and
control{-}flow passes will collection information about:

\begin{itemize}\atItemizeStart

\item \textbf{Variable use} Relevent information includes next{-}use
information (i.e. how long until the variable is referenced again). This
information is useful for register allocation (so regularly used variables
get precedence), redundant variable elimination (to remove expressions
that calculate values that are overwritten without being read), and dead
variable elimination (which doesn{'}t generate code for variables that are
never used).

\item \textbf{Control flow} The control flow for a program can be represented using a
directed{-}acyclic graph (DAG), which can be used to perform optimizations like dead{-}code elimination.\end{itemize}

Dataflow analyis is done in a later portion of compilation once the code
has been converted into a format that is easier to analyze (like basic
blocks or a{-}normal form).

\Ssubsection{Various other optimization techniques}{Various other optimization techniques}\label{t:x28part_x22Variousx5fotherx5foptimizationx5ftechniquesx22x29}

There are a plethora of other optimization techniques utilized by standard
imperative compilers. Since they tend to be lead to smaller performance
gains, and are less specific to functional languages, we{'}ll only briefly
touch on them.

\Ssubsubsection{Dead code elimination}{Dead code elimination}\label{t:x28part_x22Deadx5fcodex5feliminationx22x29}

After doing flow analysis, we can determine the control flow for the whole program,
allowing us to see which expression are executed. If we mark every line of code that
has the potential to be executed, we{'}re left with all the "dead code" (i.e. code that
cannot ever be executed in our program).

Dead code elimination cuts down wasted resource usage that is the result of lazy
programming. It can even be exposed to the programmer as a linting or code
quality metric so they can determine how much of the code in the project
is unused.

Consider the following code:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{f}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{g}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{a{-}pure{-}function}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}\end{SingleColumn}\end{SCodeFlow}

Assuming \Scribtexttt{(a{-}pure{-}function)} doesn{'}t have any side{-}effects, the calculation it
does is wasted, since \Scribtexttt{g} is never used. Therefore, the code will still be correct
if we remove the binding.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{f}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}\end{SingleColumn}\end{SCodeFlow}

This reduces the size of our code and makes further optimizations simpler and faster since
we don{'}t waste time reasoning about code that is never run.

\Ssubsubsection{Redundant assignment removal}{Redundant assignment removal}\label{t:x28part_x22Redundantx5fassignmentx5fremovalx22x29}

A similar pass related to dead{-}code elimination is redundant assignment elimination.
If we reassign to a value twice, before reassigning it (again assuming no side effects),
we can delete the first assignment.

We could then transform this code:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{30}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{20}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{set{\hbox{\texttt{!}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{30}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{println}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{30
}\end{SingleColumn}\end{SCodeFlow}

into this code:

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{30}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{println}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{x}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{30
}\end{SingleColumn}\end{SCodeFlow}

\Ssubsubsection{Loop invariant detection}{Loop invariant detection}\label{t:x28part_x22Loopx5finvariantx5fdetectionx22x29}

If code that is executed repeatedly is tuned for performance, the overall
speed of a program can improve drastically. When possible, optimizing
compilers will lift expressions inside of a loop to the surrounding scope,
if the value isn{'}t determined by the loop. For instance,

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{require}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{math/number{-}theory}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{for}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{i}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{in{-}range}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{200}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{j}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{i}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{k}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{nth{-}prime}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{20}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{j}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{k}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}\end{SingleColumn}\end{SCodeFlow}

Since \Scribtexttt{j} relies on \Scribtexttt{i}, a variable computed in the loop, we must
leave it where it is. However, \Scribtexttt{k} recalculates the 20th prime in every
iteration, despite the fact that the 20th prime never changes. Therefore,
we can "hoist" it out of the loop, and only calculate its value once.

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{require}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{math/number{-}theory}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{k}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{nth{-}prime}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{20}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{for}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{i}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{in{-}range}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{200}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{j}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{i}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xxx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{j}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{k}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}\end{SingleColumn}\end{SCodeFlow}

Loops constructs permeate imperative code, but are not as popular in functional languages,
so this type of optimization is less useful to us. However, it could still
be used for hoisting variables outside of recursive named{-}\Scribtexttt{let}s or
recursive inner functions.

\Ssubsubsection{Loop unrolling}{Loop unrolling}\label{t:x28part_x22Loopx5funrollingx22x29}

Another optimization for loops is loop unrolling, which lowers the cost of
short loop bodies. Since the short loop bodies regularly branch, it is
expensive to finish an iteration, check whether the loop is finished, then
jump to the beginning of the loop again.

Sometimes (if the loop is small enough), loop unrolling can completely
eliminate the loop, but in cases with many iterations, partially unrolling
the loop can make the loop execute more quickly. For instance,

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{for}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{i}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{in{-}range}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{20}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{print}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"hello}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{world{\hbox{\texttt{!}}}"}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{"hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}"}\end{SingleColumn}\end{SCodeFlow}

Could be rewritten as,

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{for}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{i}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{in{-}range}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{20}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{5}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{print}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"hello}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{world{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{print}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"hello}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{world{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{print}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"hello}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{world{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{print}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"hello}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{world{\hbox{\texttt{!}}}"}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{print}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{"hello}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{world{\hbox{\texttt{!}}}"}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktOut{"hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}""hello world{\hbox{\texttt{!}}}"}\end{SingleColumn}\end{SCodeFlow}

Or in a more sophisticated example,

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{position}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{\#(}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{translation}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{\#(}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{for/vector}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktPn{(}\RktMeta{p}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{position}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{t}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{translation}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{p}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{t}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}\#(3 5 3)}\end{SingleColumn}\end{SCodeFlow}

Could be rewritten,

\begin{SCodeFlow}\begin{SingleColumn}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{position}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{\#(}\RktVal{1}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{3}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{translation}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{\#(}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\Scribtexttt{{\Stttextmore}}} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\begin{RktBlk}\begin{tabular}[t]{@{}l@{}}
\hbox{\RktMeta{}\RktPn{(}\RktMeta{vector}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{vector{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{position}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{vector{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{translation}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{0}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{vector{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{position}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{vector{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{translation}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{1}\RktPn{)}\RktPn{)}\RktMeta{}} \\
\hbox{\RktMeta{}\mbox{\hphantom{\Scribtexttt{xx}}}\RktMeta{}\RktPn{(}\RktMeta{+}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{vector{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{position}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktMeta{}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktPn{(}\RktMeta{vector{-}ref}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{translation}\mbox{\hphantom{\Scribtexttt{x}}}\RktMeta{}\RktVal{2}\RktPn{)}\RktPn{)}\RktPn{)}\RktMeta{}}\end{tabular}\end{RktBlk}\end{bigtabular}

\RktRes{{\textquotesingle}\#(3 5 3)}\end{SingleColumn}\end{SCodeFlow}

Which is far more performant since we{'}ve eliminated branching.

\Ssubsection{Code generation for x86}{Code generation for x86}\label{t:x28part_x22Codex5fgenerationx5fforx5fx86x22x29}

Finally, after transforming, tweaking, and pruning our original source code, we{'}ve now
reached the point in the process where we can start generating actual machine code for
our target architecture.

\Ssubsubsection{A brief review of assembly}{A brief review of assembly}\label{t:x28part_x22Ax5fbriefx5freviewx5fofx5fassemblyx22x29}

Assembly is the lowest level series of an instructions a programmer can
provide to a computer. Most CPUs have hundreds (or thousands) of
instructions for performing mathematical, boolean algebra, memory
manipulation, and code branching operations. For the x86 architecture,
most of these instructions can be safely ignored as they{'}re only used in
rare cases, or are kept for backwards compatibility.

Despite the scores of instructions available, CPUs are fundamentally the
same as pocket calculators, just with more memory, and more conditional
logic. CPUs have a set of \textit{registers} which can each
holding a few dozen bits. For instance, 32{-}bit machines primarily have
32{-}bit registers, 64{-}bit machines have 64{-}bit registers.

Variables in assembly are just memory locations. There is no name
assocated with a variable binding, so once a program is compiled to
machine code, variable names are lost. Global variables are stored in
static locations in memory (generally precomputed before compilation), and
local variables are stored on the runtime stack.

The instructions that a program is comprised of are stored in memory in
the "text" segment. An instruction pointer points at the current machine
code instruction to execute, and can be moved to an arbitrary instruction
to perform a jump (also known as a branch). Jumps are how loops and
conditional expressions are implemented. A loop jumps back to a prior
instruction and executes the same instructions again, and conditionals are
implemented by choosing which set of instructions to execute depending on
a condition.

CPU operations are performed on registers, and must load data from memory
into a register before using it. Once an operation is completed and the
data needs to be stored for later use, it will be put back into a memory
location. Some registers are special purpose, since certain instructions
can only operate on values in specific registers. The rest are general
purpose registers and can be used for storing and transforming temporary
values.

32{-}bit register names are prefixed with an "e". In our compiler, the
immediate value (i.e. the current value we return from each expression) is
stored in \Scribtexttt{\%eax}. \Scribtexttt{\%esp} (stack pointer) and \Scribtexttt{\%ebp} (base
pointer) are important registers since they track memory address relevant
to the current stack frame. \Scribtexttt{\%eip} is the instruction pointer register,
and can be manipulated to perform jumps.

The necessary instructions for our compiler are a small subset of the
instructions available on an x86 machine.

The \Scribtexttt{mov} instruction can move 4{-}bytes constants and values between
registers and memory locations. For instance, \Scribtexttt{movl \$4, \%eax} means
"move the long (i.e. 4{-}byte) constant 4 into the \Scribtexttt{\%eax} register" and
\Scribtexttt{movl {-}4(\%ebp), \%ebx} means "move the long value stored at the memory
location \Scribtexttt{\%ebp {-} 4} to \Scribtexttt{\%ebx}."

Conditionals can{'}t be implemented without comparisons, which is when the
comparison instruction \Scribtexttt{cmp} is used. \Scribtexttt{cmp} compares its two
arguments and sets a flag in the CPU depending on whether the first value
is equal to, less than, or greater than the second value.

However, the \Scribtexttt{cmp} instruction doesn{'}t change \Scribtexttt{\%eip} to branch. The
instruction directly after determines the jump. \Scribtexttt{jz} will jump if the
\Scribtexttt{cmp} results were equal. \Scribtexttt{jne} jumps if they{'}re not equal, and
\Scribtexttt{jg} jumps if the first was greater than the second. Unconditional
jumps that don{'}t rely on the result of a \Scribtexttt{cmp} can be made with the
\Scribtexttt{jmp} instruction.

\Scribtexttt{push} and \Scribtexttt{pop} operate on the runtime stack, and can be used to
save a registers value to, or restore it from the stack. Underneath the
hood they actually juggle register values and keep track of the top of the
stack with \Scribtexttt{\%esp}.

\Scribtexttt{call} and \Scribtexttt{ret} enforce C{-}calling convention style function calls
and function returns. Some extra boilerplate is required to save and
restore the \Scribtexttt{\%ebp} and \Scribtexttt{\%esp} registers, but \Scribtexttt{call} and \Scribtexttt{ret}
track return addresses and ensure the proper value is returned from the
function when it completes.

We{'}ll be targeting the x86 architecture, since it is one of the most
prevalent architectures for desktop computers. x86{-}64 is similar, but has
larger 8{-}byte registers and passes arguments through registers rather than
pushing them onto the stack when calling functions. However, x86{-}64 is
backwards compatible with x86 (32{-}bit), so we{'}ll use 32{-}bit conventions.
It isn{'}t necessary to use C calling conventions, and a high{-}performance
functional compiler likely would use a custom convention. However, by
using C calling conventions, we{'}re able to use the \Scribtexttt{call} instruction,
and interop with C code.

The code generation rules are trivial because we{'}ve transformed the code
into a format that is simple to translate. The structure of the code is
consistently linear, meaning each expression clearly translates to a few
assembly instructions.

\includegraphics[scale=0.5]{rkttmpd54e6c9e1d53eb921607990810806bb6a94249eb.png}

Local variables are pushed onto the stack and can be accessed by adding
offsets to \Scribtexttt{\%ebp} (of 4 byte intervals for 32{-}bit x86). For instance,
to access \Scribtexttt{local 1} using pseudo C syntax, \Scribtexttt{*(\%ebp {-} 4)} (i.e. we
dereference the memory location stored in \%ebp minus an offset of
4 bytes).

Arguments are stored in a different portion of the stack and must be
accessed by adding an offset to \Scribtexttt{\%ebp}. Of course, an extra 4 bytes
must be added to step over the stack location that stores the return
address.

Function calls require some boilerplate to keep the stack in this
structure.

\label{t:x28elem_x28chunk_x22x3ccodegenx2dx86x3ex3a1x22x29x29}\textbf{\textit{\hyperref[t:x28elem_x28chunk_x22x3ccodegenx2dx86x3ex3a1x22x29x29]{\plainlink{$<$codegen{-}x86$>$}}} ::=}

\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{define{-}pass}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{emit{-}asm}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{L2}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{ir}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\RktPn{(}\RktSym{definitions}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{frame{-}locals}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{filter}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{compose}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{positive{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{cdr}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{slot{-}index}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{cond}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{findf}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{x}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{eq{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{car}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{={\Stttextmore}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{cdr}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{else}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{error}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"failed to get index for"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{define}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{emit{-}immediate}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{match}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{variable{\hbox{\texttt{?}}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\%name{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{format}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"\$$\sim$a"}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{clean{-}\%name}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{format}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"$\sim$a(\%ebp)"}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\mbox{{-}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{+word{-}size+}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{slot{-}index}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{number{\hbox{\texttt{?}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{format}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"\$$\sim$a"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{{\hbox{\texttt{?}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{boolean{\hbox{\texttt{?}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{format}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"\$$\sim$a"}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{0}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{x}}}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{:}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{ir}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{frame}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\RktPn{)}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{\mbox{{-}{\Stttextmore}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktRdr{,}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"movl $\sim$a, \%eax{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{emit{-}immediate}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktRdr{,}\RktSym{c}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"movl $\sim$a, \%eax{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{emit{-}immediate}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{c}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{begin}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{begin}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{map}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{curryr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e*}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{if}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e1}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e2}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{else{-}label}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{gensym}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{else}\RktPn{)}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{end{-}label}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{gensym}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{end}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"cmp \$0, \%eax{\char`\\}n"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"jz $\sim$a{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{else{-}label}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"jmp $\sim$a{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{end{-}label}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"$\sim$a{\hbox{\texttt{:}}}{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{else{-}label}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e2}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"$\sim$a{\hbox{\texttt{:}}}{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{end{-}label}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{body}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"subl \$4, \%esp{\char`\\}n"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{let}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{(}\RktSym{slot}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{add1}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{length}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{frame{-}locals}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"movl \%eax, $\sim$a(\%ebp){\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\mbox{{-}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{+word{-}size+}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{slot}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{body}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{slot}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{lref}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{x}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"movl \$$\sim$a, \%eax{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktRdr{,}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e1}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e0}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{for{-}each}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{v}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"pushl $\sim$a{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{emit{-}immediate}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{v}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktSym{e1}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"call *\%eax{\char`\\}n"}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{label}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktRdr{,}\RktSym{x*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{body}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"{\hbox{\texttt{.}}}global $\sim$a{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"{\hbox{\texttt{.}}}type $\sim$a @function{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"{\hbox{\texttt{.}}}align 8{\char`\\}n"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"$\sim$a{\hbox{\texttt{:}}}{\char`\\}n"}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"pushl \%ebp{\char`\\}n"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"movl \%esp, \%ebp{\char`\\}n"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{body}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{map}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{lambda}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{a}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{i}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{cons}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{a}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{\mbox{{-}}}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{i}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktSym{x*}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{iota}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{length}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x*}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{2}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"movl \%ebp, \%esp{\char`\\}n"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"popl \%ebp{\char`\\}n"}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{printf}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{"ret{\char`\\}n"}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktPn{(}\RktSym{program}\mbox{\hphantom{\Scribtexttt{x}}}\RktRdr{,}\RktSym{e*}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}}}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{for{-}each}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{curryr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{frame}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{e*}\RktPn{)}\RktPn{)}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\RktPn{(}\RktSym{Expr}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{ir}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{{\textquotesingle}}\RktVal{(}\RktVal{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

\sectionNewpage

\Ssection{Conclusions}{Conclusions}\label{t:x28part_x22Conclusionsx22x29}

In the last few chapters, we{'}ve learned to use Racket to build parsers
using traditional parser tools like \Scribtexttt{lex} and \Scribtexttt{yacc}. We{'}ve looked
into the more advanced approach of using parser combinators, and seen how
they compare to \Scribtexttt{lex} and \Scribtexttt{yacc}.

We{'}ve breifly looked at interpreter implementation, and how modern
"interpreters" use bytecode virtual machines to improve performance. Some
even perform more compilation steps in the bytecode interpreter to JIT
code for native speeds.

Finally, we looked at how compilers work, and how the passes for common
transformations could be implemented in a nanopass compiler. The full
source is available at
\href{https://github.com/charles-l/comp/tree/master/fir}{\Snolinkurl{https://github.com/charles-l/comp/tree/master/fir}} for reader
experimentation.

\Ssubsection{Where to go from here}{Where to go from here}\label{t:x28part_x22Wherex5ftox5fgox5ffromx5fherex22x29}

Given the constraints, this introduction only scratches the surface of
programming language implementations. Many resources exist for those who
are more interested in this area of computer science.

As mentioned many times throughout this book, Structure and Interpretation
of Computer programs [\hyperref[t:x28cite_x22SICPx22x29]{SICP}] is a great introduction to many
interpreter and compiler concepts, and is a good place to start before
delving into more advanced literature.

The Tiger Book [\hyperref[t:x28cite_x22Appelx2c_1998x22x29]{Appel, 1998}] is more advanced, and goes into more
detail about many of the details of a compiler. The [Dragon Book] is
even more advanced, and is considered a classic in the compiler community.
It is primarily focused on imperative compilers, but most of the
information is useful to functional languages.

For jitted interpreters, there aren{'}t really any books on the subject.
There are a smattering of blog posts and academic papers on the subject,
but no central source of knowledge. The best way to learn about JITs is to
study real implementations for LuaJIT or V8, and play with the source
code.

There is a good chance this book will continue to receive updates into the
future. If it does, the source code and book contents at
\href{https://github.com/charles-l/capstone}{\Snolinkurl{https://github.com/charles-l/capstone}} will be updated.

\sectionNewpage

\Ssection{References}{References}\label{t:x28part_x22Referencesx22x29}

\label{t:x28part_x28gentag_0x29x29}



\Ssubsectionstarx{Bibliography}{Bibliography}\label{t:x28part_x22docx2dbibliographyx22x29}

\begin{RBibliography}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}l@{}}
\hbox{\label{t:x28cite_x22Dragon_bookx22x29}[Dragon book]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Alfred V. Aho, Monica S. Lam, Ravi Sethi and Jeffrey D. Ullman, \textit{Compilers: Principles, Techniques, \& Tools}.}} \\
\hbox{\label{t:x28cite_x22SICPx22x29}[SICP]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Harold Abelson, Jerry Sussman and Julia Sussman, \textit{Structure and Interpretation of Computer Programs}.}} \\
\hbox{\label{t:x28cite_x22Trompx22x29}[Tromp]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{John Tromp, {``}Binary Lambda Calculus and Combinatory Logic.{''} \href{https://tromp.github.io/cl/LC.pdf}{\Scribtexttt{https{\hbox{\texttt{:}}}//tromp{\hbox{\texttt{.}}}github{\hbox{\texttt{.}}}io/cl/LC{\hbox{\texttt{.}}}pdf}}}} \\
\hbox{\label{t:x28cite_x22DrSchemex22x29}[DrScheme]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Robert Bruce Findler, John Clements, Cormac Flanagan, Matthew Flatt, Shriram Krishnamurthi, Paul Steckler and Matthias Felleisen, {``}DrScheme: A Programming Environment for Scheme.{''} \href{https://users.soe.ucsc.edu/~cormac/papers/jfp01.pdf}{\Scribtexttt{https{\hbox{\texttt{:}}}//users{\hbox{\texttt{.}}}soe{\hbox{\texttt{.}}}ucsc{\hbox{\texttt{.}}}edu/$\sim$cormac/papers/jfp01{\hbox{\texttt{.}}}pdf}}}} \\
\hbox{\label{t:x28cite_x22The_Little_Schemerx22x29}[The Little Schemer]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Daniel P. Friedman and Matthias Felleisen, \textit{The Little Schemer}.}} \\
\hbox{\label{t:x28cite_x22Leijenx2c_2001x22x29}[Leijen, 2001]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Daan Leijen and Erik Meijer, {``}Parsec: Direct Style Monadic Parser Combinators For The Real World.{''} \href{https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf}{\Scribtexttt{https{\hbox{\texttt{:}}}//www{\hbox{\texttt{.}}}microsoft{\hbox{\texttt{.}}}com/en{-}us/research/wp{-}content/uploads/2016/02/parsec{-}paper{-}letter{\hbox{\texttt{.}}}pdf}}}} \\
\hbox{\label{t:x28cite_x22Types_and_PLx22x29}[Types and PL]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Benjamin C. Pierce, \textit{Types and Programming Languages}.}} \\
\hbox{\label{t:x28cite_x22Parsack_docsx22x29}[Parsack docs]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Stephen Chang, {``}Parsack Documentation.{''} \href{http://docs.racket-lang.org/parsack/index.html}{\Scribtexttt{http{\hbox{\texttt{:}}}//docs{\hbox{\texttt{.}}}racket{-}lang{\hbox{\texttt{.}}}org/parsack/index{\hbox{\texttt{.}}}html}}}} \\
\hbox{\label{t:x28cite_x22McCarthyx2c_1978x22x29}[McCarthy, 1978]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{John McCarthy, {``}A Micro{-}manual for Lisp {-} Not the Whole Truth.{''}}} \\
\hbox{\label{t:x28cite_x22Churchx2c_1932x22x29}[Church, 1932]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Alonzo Church, {``}A Set of Postulates for the Foundation of Logic..{''}}} \\
\hbox{\label{t:x28cite_x22Yunhex2c_2005x22x29}[Yunhe, 2005]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Yunhe Shi, David Gregg, Andrew Beatty and M. Anton Ertl, {``}Virtual Machine Showdown: Stack Versus Registers.{''}}} \\
\hbox{\label{t:x28cite_x22Flanaganx2c_1993x22x29}[Flanagan, 1993]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Cormac Flanagan, Amr Sabry, Bruce F. Duba and Matthias Felleisen, {``}The Essence of Compiling with Continuations.{''}}} \\
\hbox{\label{t:x28cite_x22Appelx2c_1998x22x29}[Appel, 1998]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Andrew W. Appel, \textit{Modern Compiler Implementation in Java}.}} \\
\hbox{\label{t:x28cite_x22Chomskyx2c_1956x22x29}[Chomsky, 1956]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Noam Chomsky, {``}Three Models for the Description of Language.{''}}} \\
\hbox{\label{t:x28cite_x22Sarkarx2c_2005x22x29}[Sarkar, 2005]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Dipanwita Sarkar, Oscar Waddell and R. Kent Dybvig, {``}A Nanopass Framework for Compiler Education.{''}}} \\
\hbox{\label{t:x28cite_x22Keepx2c_2012x22x29}[Keep, 2012]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Andrew W. Keep, {``}A Nanopass Framework for Commercial Compiler Development.{''}}} \\
\hbox{\label{t:x28cite_x22Keepx2c_2013x22x29}[Keep, 2013]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Andrew W. Keep and R. Kent Dybvig, {``}A Nanopass Framework for Commercial Compiler Development.{''}}} \\
\hbox{\label{t:x28cite_x22nanopassx2dracket_documentationx22x29}[nanopass{-}racket documentation]} &
\hbox{\mbox{\hphantom{\Scribtexttt{x}}}} &
\hbox{\bibentry{Andrew W. Keep and Leif Anderson, {``}Nanopass Framework.{''} \href{https://docs.racket-lang.org/nanopass/index.html}{\Scribtexttt{https{\hbox{\texttt{:}}}//docs{\hbox{\texttt{.}}}racket{-}lang{\hbox{\texttt{.}}}org/nanopass/index{\hbox{\texttt{.}}}html}}}}\end{bigtabular}\end{RBibliography}

\postDoc
\end{document}
